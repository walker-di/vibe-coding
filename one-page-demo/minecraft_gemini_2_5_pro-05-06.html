<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniCraft.js with Cannon.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #instructions {
      width: 50%;
      max-width: 400px;
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: center;
      color: white;
      background-color: rgba(50, 50, 50, 0.8);
      border-radius: 10px;
      cursor: pointer;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 10px;
      background-color: white;
      transform: translate(-50%, -50%);
      pointer-events: none;
      mix-blend-mode: difference;
    }

    #crosshair::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -4px;
      width: 10px;
      height: 2px;
      background-color: white;
      transform: translateY(-50%);
    }

    #block-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      gap: 10px;
    }

    .block-option {
      width: 40px;
      height: 40px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      user-select: none;
    }

    .block-option.selected {
      border-color: white;
      box-shadow: 0 0 10px cyan;
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <h1>MiniCraft.js</h1>
      <p>Click to play</p>
      <p>WASD: Move<br>Space: Jump<br>Shift: Descend (Creative Fly)<br>Mouse: Look<br>Left Click: Place Block<br>Right
        Click: Remove
        Block<br>1-4: Select Block Type</p>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="block-selector"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, camera, renderer, controls;
    let worldObjects = []; // To keep track of Three.js breakable/placeable blocks

    // Cannon.js specific variables
    let world; // Cannon.js physics world
    let playerBody; // Cannon.js body for the player
    const timeStep = 1 / 60; // Physics simulation step (60 FPS)
    let playerMaterial, groundMaterial, playerGroundContactMaterial;


    const worldSize = { width: 20, depth: 20, height: 10 };
    const blockSize = 1;

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let moveUpAction = false; // For triggering jump in animate loop
    let moveDown = false; // Descend (like creative mode fly)

    // Player physical properties
    const playerHeight = 1.8;
    const playerRadius = 0.4; // Used for width/depth of the player's physics box
    const playerSpeed = 5.0;
    const jumpVelocity = 7.0; // Adjusted for Cannon's gravity
    const gravity = 20.0; // Matches Cannon's default somewhat, but we set explicitly
    let canJump = false;

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(); // For mouse picking, center of screen

    const blockTypes = {
      GRASS: 'grass',
      DIRT: 'dirt',
      STONE: 'stone',
      WOOD: 'wood'
    };
    let currentBlockType = blockTypes.GRASS;
    const blockMaterials = {}; // Three.js materials

    let lastTime = performance.now();

    init();
    animate();

    function createTexture(color, text = null) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.fillRect(0, 0, 64, 64);
      context.strokeStyle = 'rgba(0,0,0,0.2)';
      context.lineWidth = 2;
      context.strokeRect(1, 1, 62, 62);
      if (text) {
        context.fillStyle = 'rgba(0,0,0,0.5)';
        context.font = '12px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 32, 32);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    function initMaterials() {
      const grassTopTexture = createTexture('#6A994E');
      const grassSideTexture = createTexture('#A7C957');
      const dirtTexture = createTexture('#8C6A48');
      const stoneTexture = createTexture('#808080');
      const woodTexture = createTexture('#A0522D');

      blockMaterials[blockTypes.GRASS] = [
        grassSideTexture, grassSideTexture, grassTopTexture, dirtTexture, grassSideTexture, grassSideTexture
      ].map(texture => new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 }));
      blockMaterials[blockTypes.DIRT] = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9, metalness: 0 });
      blockMaterials[blockTypes.STONE] = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.2 });
      blockMaterials[blockTypes.WOOD] = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
    }

    function init() {
      // --- Three.js Scene Setup ---
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 10, 75);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      // Initial camera position will be synced with playerBody later

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(50, 80, 30);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 200;
      const shadowCamSize = 30;
      directionalLight.shadow.camera.left = -shadowCamSize;
      directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize;
      directionalLight.shadow.camera.bottom = -shadowCamSize;
      scene.add(directionalLight);

      initMaterials(); // Initialize Three.js block materials

      // --- Cannon.js Physics Setup ---
      world = new CANNON.World();
      world.gravity.set(0, -gravity, 0);
      world.broadphase = new CANNON.NaiveBroadphase(); // Efficient for many static objects

      // Define materials for Cannon.js
      playerMaterial = new CANNON.Material("playerMaterial");
      groundMaterial = new CANNON.Material("groundMaterial");

      playerGroundContactMaterial = new CANNON.ContactMaterial(
        playerMaterial,
        groundMaterial,
        {
          friction: 0.0, // Low friction for Minecraft-like movement against blocks
          restitution: 0.0 // No bounce
        }
      );
      world.addContactMaterial(playerGroundContactMaterial);

      // Create Player Physics Body
      const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius));
      const initialPlayerPos = new THREE.Vector3(worldSize.width / 4, worldSize.height + 2, worldSize.depth / 4);
      playerBody = new CANNON.Body({
        mass: 70, // kg
        position: new CANNON.Vec3(initialPlayerPos.x, initialPlayerPos.y, initialPlayerPos.z),
        shape: playerShape,
        material: playerMaterial,
        fixedRotation: true, // Prevents player from tipping over
        linearDamping: 0.3 // Helps player come to a stop naturally
      });
      world.addBody(playerBody);

      playerBody.addEventListener("collide", function (event) {
        const contact = event.contact;
        const upAxis = new CANNON.Vec3(0, 1, 0);
        let contactNormal = new CANNON.Vec3();

        // Check which body is the player and get the contact normal relative to the player
        if (contact.bi.id === playerBody.id) {
          contact.ni.negate(contactNormal); // Normal of contact point on player body
        } else {
          contactNormal.copy(contact.ni); // Normal of contact point on other body (points away from other body)
        }

        // Check if the collision is with a surface below the player
        // (contact normal is pointing upwards relative to the player)
        if (contactNormal.dot(upAxis) > 0.5) { // 0.5 is a threshold, >0 means some upward component
          const otherBody = (contact.bi.id === playerBody.id) ? contact.bj : contact.bi;
          if (otherBody.mass === 0) { // Check if colliding with a static object (ground/block)
            canJump = true;
          }
        }
      });


      generateWorld(); // Generates Three.js meshes AND Cannon.js bodies

      // --- Controls ---
      controls = new PointerLockControls(camera, document.body);
      camera.position.set(0, 0.7, 0); // Eye height relative to playerBody's center (0.7 makes eyes at ~1.6m for 1.8m height)
      controls.getObject().position.copy(playerBody.position); // Initial sync
      scene.add(controls.getObject());


      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');
      instructions.addEventListener('click', () => controls.lock());
      controls.addEventListener('lock', () => {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
      });
      controls.addEventListener('unlock', () => {
        blocker.style.display = 'flex';
        instructions.style.display = '';
      });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousedown', onMouseDown);

      setupBlockSelector();
    }

    function generateWorld() {
      const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

      for (let x = 0; x < worldSize.width; x++) {
        for (let z = 0; z < worldSize.depth; z++) {
          const groundLevel = Math.floor(worldSize.height / 3);
          const height = groundLevel + Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let material;
            let blockType;
            if (y === height - 1 && y >= groundLevel) {
              material = blockMaterials[blockTypes.GRASS];
              blockType = blockTypes.GRASS;
            } else if (y < height - 1 && y >= groundLevel - 2) {
              material = blockMaterials[blockTypes.DIRT];
              blockType = blockTypes.DIRT;
            } else {
              material = blockMaterials[blockTypes.STONE];
              blockType = blockTypes.STONE;
            }
            const blockMesh = new THREE.Mesh(boxGeometry, material);
            blockMesh.position.set(
              x * blockSize - (worldSize.width * blockSize / 2) + blockSize / 2,
              y * blockSize + blockSize / 2,
              z * blockSize - (worldSize.depth * blockSize / 2) + blockSize / 2
            );
            blockMesh.castShadow = true;
            blockMesh.receiveShadow = true;
            blockMesh.userData.blockType = blockType;
            scene.add(blockMesh);
            worldObjects.push(blockMesh);

            // Create Cannon.js body for the block
            const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2));
            const blockBody = new CANNON.Body({
              mass: 0, // Static
              shape: blockShape,
              position: new CANNON.Vec3(blockMesh.position.x, blockMesh.position.y, blockMesh.position.z),
              material: groundMaterial
            });
            world.addBody(blockBody);
            blockMesh.userData.cannonBody = blockBody; // Link Three.js mesh to Cannon.js body
          }
        }
      }

      // Ground plane (visual)
      const groundGeo = new THREE.PlaneGeometry(worldSize.width * blockSize * 1.5, worldSize.depth * blockSize * 1.5);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x778899, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.position.y = -blockSize / 2;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      // Cannon.js ground plane (physics)
      const groundPlaneShape = new CANNON.Plane();
      const groundPlaneBody = new CANNON.Body({
        mass: 0, // Static
        shape: groundPlaneShape,
        material: groundMaterial,
        position: new CANNON.Vec3(0, groundMesh.position.y, 0) // Match visual ground plane position
      });
      groundPlaneBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be horizontal
      world.addBody(groundPlaneBody);
    }

    function setupBlockSelector() {
      const selectorDiv = document.getElementById('block-selector');
      Object.keys(blockTypes).forEach((key) => {
        const type = blockTypes[key];
        const option = document.createElement('div');
        option.classList.add('block-option');
        option.textContent = key.substring(0, 1);
        option.style.backgroundColor = getBlockColor(type);
        option.title = key;
        option.dataset.blockType = type;
        if (type === currentBlockType) {
          option.classList.add('selected');
        }
        option.addEventListener('click', () => {
          currentBlockType = type;
          updateBlockSelectorUI();
        });
        selectorDiv.appendChild(option);
      });
    }

    function getBlockColor(type) {
      switch (type) {
        case blockTypes.GRASS: return '#6A994E';
        case blockTypes.DIRT: return '#8C6A48';
        case blockTypes.STONE: return '#808080';
        case blockTypes.WOOD: return '#A0522D';
        default: return '#FFFFFF';
      }
    }

    function updateBlockSelectorUI() {
      document.querySelectorAll('.block-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.blockType === currentBlockType);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      switch (event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space': if (canJump) moveUpAction = true; break;
        case 'ShiftLeft': moveDown = true; break;
        case 'Digit1': currentBlockType = blockTypes.GRASS; updateBlockSelectorUI(); break;
        case 'Digit2': currentBlockType = blockTypes.DIRT; updateBlockSelectorUI(); break;
        case 'Digit3': currentBlockType = blockTypes.STONE; updateBlockSelectorUI(); break;
        case 'Digit4': currentBlockType = blockTypes.WOOD; updateBlockSelectorUI(); break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyD': moveRight = false; break;
        case 'ShiftLeft': moveDown = false; break;
      }
    }

    function onMouseDown(event) {
      if (!controls.isLocked) return;

      pointer.set(0, 0); // Raycast from center of camera
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(worldObjects, false);

      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (event.button === 2 || event.ctrlKey) { // Right click or Ctrl+LeftClick to remove
          if (intersect.object.userData.blockType && intersect.object.userData.cannonBody) {
            world.removeBody(intersect.object.userData.cannonBody);
            scene.remove(intersect.object);
            worldObjects.splice(worldObjects.indexOf(intersect.object), 1);
            if (intersect.object.geometry) intersect.object.geometry.dispose();
            if (intersect.object.material) {
              if (Array.isArray(intersect.object.material)) {
                intersect.object.material.forEach(m => m.dispose());
              } else {
                intersect.object.material.dispose();
              }
            }
          }
        } else if (event.button === 0) { // Left click to place
          const placementPosition = new THREE.Vector3();
          placementPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, blockSize);

          // Check for player collision with new block
          const newBlockHalfExtents = new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2);
          const newBlockAABB = new CANNON.AABB({
            lowerBound: new CANNON.Vec3(placementPosition.x - newBlockHalfExtents.x, placementPosition.y - newBlockHalfExtents.y, placementPosition.z - newBlockHalfExtents.z),
            upperBound: new CANNON.Vec3(placementPosition.x + newBlockHalfExtents.x, placementPosition.y + newBlockHalfExtents.y, placementPosition.z + newBlockHalfExtents.z)
          });

          playerBody.computeAABB(); // Ensure player's AABB is up-to-date
          if (newBlockAABB.overlaps(playerBody.aabb)) {
            console.log("Cannot place block: intersects player.");
            return;
          }

          let blockExists = worldObjects.some(obj => obj.position.distanceTo(placementPosition) < 0.1);
          if (!blockExists) {
            const newBlockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const newBlockMaterial = blockMaterials[currentBlockType] || blockMaterials[blockTypes.STONE];
            const newBlockMesh = new THREE.Mesh(newBlockGeometry, newBlockMaterial);
            newBlockMesh.position.copy(placementPosition);
            newBlockMesh.castShadow = true;
            newBlockMesh.receiveShadow = true;
            newBlockMesh.userData.blockType = currentBlockType;
            scene.add(newBlockMesh);
            worldObjects.push(newBlockMesh);

            // Add Cannon.js body for the new block
            const newBlockShape = new CANNON.Box(newBlockHalfExtents);
            const newBlockBody = new CANNON.Body({
              mass: 0,
              shape: newBlockShape,
              position: new CANNON.Vec3(newBlockMesh.position.x, newBlockMesh.position.y, newBlockMesh.position.z),
              material: groundMaterial
            });
            world.addBody(newBlockBody);
            newBlockMesh.userData.cannonBody = newBlockBody;
          }
        }
      }
    }

    const direction = new THREE.Vector3(); // For movement calculation
    const FWD = new THREE.Vector3(0, 0, -1);
    const RIGHT = new THREE.Vector3(1, 0, 0);

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      // Step the physics world
      if (world) {
        world.step(timeStep, delta, 3); // fixed timestep, time since last frame, max sub-steps
      }

      if (controls.isLocked) {
        const playerObject = controls.getObject(); // This is the THREE.Object3D for the player (camera parent)

        // Get current velocity from playerBody to preserve Y velocity from gravity/jump
        const currentVelocity = new CANNON.Vec3(playerBody.velocity.x, playerBody.velocity.y, playerBody.velocity.z);

        // Calculate FWD and RIGHT vectors based on playerObject's (camera parent's) orientation
        FWD.set(0, 0, -1).applyQuaternion(playerObject.quaternion);
        RIGHT.set(1, 0, 0).applyQuaternion(playerObject.quaternion);

        // Reset XZ velocity before applying new input, Y velocity is preserved for gravity/jump
        playerBody.velocity.x = 0;
        playerBody.velocity.z = 0;

        // Horizontal movement
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.z = Number(moveForward) - Number(moveBackward);
        // No normalization needed here as we sum scaled basis vectors

        if (direction.x !== 0 || direction.z !== 0) {
          // Project onto XZ plane and normalize to ensure consistent speed
          const moveDir = new THREE.Vector3(
            RIGHT.x * direction.x + FWD.x * direction.z,
            0, // Movement is planar
            RIGHT.z * direction.x + FWD.z * direction.z
          ).normalize();

          playerBody.velocity.x = moveDir.x * playerSpeed;
          playerBody.velocity.z = moveDir.z * playerSpeed;
        }

        // Apply Y velocity from previous step (gravity, etc.)
        playerBody.velocity.y = currentVelocity.y;


        // Vertical movement (Jump/Fly)
        if (moveUpAction && canJump) {
          playerBody.velocity.y = jumpVelocity;
          canJump = false;
          moveUpAction = false;
        }
        if (moveDown) { // Creative fly down
          playerBody.velocity.y = -playerSpeed;
          canJump = false; // Cannot jump while actively flying down
        }

        // Sync Three.js player object to Cannon.js body position
        playerObject.position.copy(playerBody.position);

        // Fall off world
        if (playerBody.position.y < -30) {
          playerBody.position.set(worldSize.width / 4, worldSize.height + 10, worldSize.depth / 4);
          playerBody.velocity.set(0, 0, 0);
          canJump = false; // Reset jump state
        }
      }

      renderer.render(scene, camera);
    }

  </script>
</body>

</html>