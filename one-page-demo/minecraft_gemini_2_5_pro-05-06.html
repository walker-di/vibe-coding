<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniCraft.js with Cannon.js - Advanced Blocks</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #instructions {
      width: 50%;
      max-width: 400px;
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: center;
      color: white;
      background-color: rgba(50, 50, 50, 0.8);
      border-radius: 10px;
      cursor: pointer;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 10px;
      background-color: white;
      transform: translate(-50%, -50%);
      pointer-events: none;
      mix-blend-mode: difference;
    }

    #crosshair::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -4px;
      width: 10px;
      height: 2px;
      background-color: white;
      transform: translateY(-50%);
    }

    #block-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      gap: 10px;
    }

    .block-option {
      width: 40px;
      height: 40px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      user-select: none;
      font-size: 10px;
      /* smaller font for more chars */
    }

    .block-option.selected {
      border-color: white;
      box-shadow: 0 0 10px cyan;
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <h1>MiniCraft.js</h1>
      <p>Click to play</p>
      <p>WASD: Move<br>Space: Jump / Swim Up<br>Shift: Descend / Swim Down<br>Mouse: Look<br>Left Click: Place
        Block<br>Right
        Click: Remove Block<br>1-7: Select Block Type</p>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="block-selector"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, camera, renderer, controls;
    let worldObjects = []; // To keep track of Three.js breakable/placeable blocks

    // Cannon.js specific variables
    let world; // Cannon.js physics world
    let playerBody; // Cannon.js body for the player
    const timeStep = 1 / 60; // Physics simulation step (60 FPS)
    let playerMaterial, groundMaterial, playerGroundContactMaterial;


    const worldSize = { width: 20, depth: 20, height: 10 };
    const blockSize = 1;

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let moveUpAction = false; // For triggering jump/swim_up in animate loop
    let moveDown = false; // Descend / swim_down

    // Player physical properties
    const playerHeight = 1.8;
    const playerRadius = 0.4; // Used for width/depth of the player's physics box
    const playerSpeed = 5.0;
    const jumpVelocity = 7.0; // Adjusted for Cannon's gravity
    const initialGravity = 20.0; // Matches Cannon's default somewhat, but we set explicitly
    let canJump = false;

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(); // For mouse picking, center of screen

    const blockTypes = {
      GRASS: 'grass',
      DIRT: 'dirt',
      STONE: 'stone',
      WOOD: 'wood',
      WATER: 'water',
      LAVA: 'lava',
      GLOWSTONE: 'glowstone'
    };
    let currentBlockType = blockTypes.GRASS;
    const blockMaterials = {}; // Three.js materials

    let lastTime = performance.now();

    // Fluid interaction variables
    let isInWater = false;
    let waterContactCount = 0;
    const originalGravityY = -initialGravity; // Store the original gravity's Y component
    const waterProperties = {
      gravityFactor: 0.3, // Player feels lighter in water
      speedFactor: 0.5,   // Player moves slower
      damping: 0.9,      // Increased damping for water
      swimUpVelocity: 4.0,
      swimDownVelocity: -4.0
    };
    const originalPlayerDamping = 0.3; // Store original player damping


    init();
    animate();

    function createTexture(color, text = null, isFluid = false) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.fillRect(0, 0, 64, 64);
      if (!isFluid) { // Don't draw border for fluids, looks better when tiled
        context.strokeStyle = 'rgba(0,0,0,0.2)';
        context.lineWidth = 2;
        context.strokeRect(1, 1, 62, 62);
      }
      if (text) {
        context.fillStyle = isFluid ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.5)';
        context.font = '10px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 32, 32);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    function initMaterials() {
      const grassTopTexture = createTexture('#6A994E');
      const grassSideTexture = createTexture('#A7C957');
      const dirtTexture = createTexture('#8C6A48');
      const stoneTexture = createTexture('#808080');
      const woodTexture = createTexture('#A0522D');

      const waterTexture = createTexture('rgba(50, 100, 200, 0.6)', null, true);
      const lavaTexture = createTexture('#FF6000', null, true);
      const glowstoneTexture = createTexture('#FFEE88', 'GLOW');

      blockMaterials[blockTypes.GRASS] = [
        grassSideTexture, grassSideTexture, grassTopTexture, dirtTexture, grassSideTexture, grassSideTexture
      ].map(texture => new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 }));
      blockMaterials[blockTypes.DIRT] = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9, metalness: 0 });
      blockMaterials[blockTypes.STONE] = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.2 });
      blockMaterials[blockTypes.WOOD] = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });

      blockMaterials[blockTypes.WATER] = new THREE.MeshStandardMaterial({
        map: waterTexture,
        transparent: true,
        opacity: 0.6,
        roughness: 0.2,
        metalness: 0.0,
        side: THREE.DoubleSide // Render inside of water blocks if player is inside
      });
      blockMaterials[blockTypes.LAVA] = new THREE.MeshStandardMaterial({
        map: lavaTexture,
        roughness: 0.8,
        metalness: 0.2,
        emissive: new THREE.Color(0xdd4400),
        emissiveIntensity: 0.8,
        side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.GLOWSTONE] = new THREE.MeshStandardMaterial({
        map: glowstoneTexture,
        roughness: 0.9,
        metalness: 0.1,
        emissive: new THREE.Color(0xffffaa),
        emissiveIntensity: 0.9
      });
    }

    function init() {
      // --- Three.js Scene Setup ---
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 10, 75);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 80, 30);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 200;
      const shadowCamSize = 30;
      directionalLight.shadow.camera.left = -shadowCamSize;
      directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize;
      directionalLight.shadow.camera.bottom = -shadowCamSize;
      scene.add(directionalLight);

      initMaterials();

      // --- Cannon.js Physics Setup ---
      world = new CANNON.World();
      world.gravity.set(0, -initialGravity, 0);
      world.broadphase = new CANNON.NaiveBroadphase();

      playerMaterial = new CANNON.Material("playerMaterial");
      groundMaterial = new CANNON.Material("groundMaterial"); // Used for all static blocks

      playerGroundContactMaterial = new CANNON.ContactMaterial(
        playerMaterial,
        groundMaterial,
        {
          friction: 0.0,
          restitution: 0.0
        }
      );
      world.addContactMaterial(playerGroundContactMaterial);

      const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius));
      const initialPlayerPos = new THREE.Vector3(worldSize.width / 4, worldSize.height + 2, worldSize.depth / 4);
      playerBody = new CANNON.Body({
        mass: 70,
        position: new CANNON.Vec3(initialPlayerPos.x, initialPlayerPos.y, initialPlayerPos.z),
        shape: playerShape,
        material: playerMaterial,
        fixedRotation: true,
        linearDamping: originalPlayerDamping
      });
      world.addBody(playerBody);

      playerBody.addEventListener("collide", function (event) {
        const contact = event.contact;
        const upAxis = new CANNON.Vec3(0, 1, 0);
        let contactNormal = new CANNON.Vec3();

        if (contact.bi.id === playerBody.id) {
          contact.ni.negate(contactNormal);
        } else {
          contactNormal.copy(contact.ni);
        }

        if (contactNormal.dot(upAxis) > 0.5) {
          const otherBody = (contact.bi.id === playerBody.id) ? contact.bj : contact.bi;
          if (otherBody.mass === 0 && otherBody.collisionResponse !== 0) { // Solid static object
            if (!isInWater) {
              canJump = true;
            }
          }
        }
      });

      playerBody.addEventListener("beginContact", function (event) {
        const otherBody = event.bodyA.id === playerBody.id ? event.bodyB : event.bodyA;
        if (otherBody.collisionResponse === 0 && otherBody.userData) { // Is it a sensor?
          if (otherBody.userData.blockType === blockTypes.WATER) {
            enterWater();
          } else if (otherBody.userData.blockType === blockTypes.LAVA) {
            enterLava();
          }
        }
      });

      playerBody.addEventListener("endContact", function (event) {
        const otherBody = event.bodyA.id === playerBody.id ? event.bodyB : event.bodyA;
        if (otherBody.collisionResponse === 0 && otherBody.userData) {
          if (otherBody.userData.blockType === blockTypes.WATER) {
            exitWater();
          }
        }
      });


      generateWorld();

      // --- Controls ---
      controls = new PointerLockControls(camera, document.body);
      camera.position.set(0, 0.7, 0); // Eye height relative to playerBody's center
      controls.getObject().position.copy(playerBody.position); // Initial sync
      scene.add(controls.getObject());


      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');
      instructions.addEventListener('click', () => controls.lock());
      controls.addEventListener('lock', () => {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
      });
      controls.addEventListener('unlock', () => {
        blocker.style.display = 'flex';
        instructions.style.display = '';
      });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousedown', onMouseDown);

      setupBlockSelector();
    }

    function enterWater() {
      waterContactCount++;
      if (!isInWater && waterContactCount > 0) {
        isInWater = true;
        world.gravity.set(0, originalGravityY * waterProperties.gravityFactor, 0);
        playerBody.linearDamping = waterProperties.damping;
        console.log("Entered water");
      }
    }

    function exitWater() {
      waterContactCount--;
      if (isInWater && waterContactCount <= 0) {
        isInWater = false;
        waterContactCount = 0; // Ensure it's not negative
        world.gravity.set(0, originalGravityY, 0);
        playerBody.linearDamping = originalPlayerDamping;
        console.log("Exited water");
      }
    }

    function enterLava() {
      console.log("Player touched LAVA!");
      playerBody.position.set(worldSize.width / 4, worldSize.height + 10, worldSize.depth / 4);
      playerBody.velocity.set(0, 0, 0);
      if (isInWater) { // If somehow was in water too
        waterContactCount = 0; // Reset counter
        exitWater(); // Call exitWater to reset gravity and damping
      }
    }


    function generateWorld() {
      const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

      for (let x = 0; x < worldSize.width; x++) {
        for (let z = 0; z < worldSize.depth; z++) {
          const groundLevel = Math.floor(worldSize.height / 3);
          const height = groundLevel + Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let material;
            let blockType;
            if (y === height - 1 && y >= groundLevel) {
              material = blockMaterials[blockTypes.GRASS];
              blockType = blockTypes.GRASS;
            } else if (y < height - 1 && y >= groundLevel - 2) {
              material = blockMaterials[blockTypes.DIRT];
              blockType = blockTypes.DIRT;
            } else {
              material = blockMaterials[blockTypes.STONE];
              blockType = blockTypes.STONE;
            }
            const blockMesh = new THREE.Mesh(boxGeometry, material);
            blockMesh.position.set(
              x * blockSize - (worldSize.width * blockSize / 2) + blockSize / 2,
              y * blockSize + blockSize / 2,
              z * blockSize - (worldSize.depth * blockSize / 2) + blockSize / 2
            );
            blockMesh.castShadow = true;
            blockMesh.receiveShadow = true;
            blockMesh.userData.blockType = blockType;
            scene.add(blockMesh);
            worldObjects.push(blockMesh);

            // Create Cannon.js body for the block
            const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2));
            const blockBody = new CANNON.Body({
              mass: 0, // Static
              shape: blockShape,
              position: new CANNON.Vec3(blockMesh.position.x, blockMesh.position.y, blockMesh.position.z),
              material: groundMaterial
            });
            world.addBody(blockBody);
            blockMesh.userData.cannonBody = blockBody; // Link Three.js mesh to Cannon.js body
          }
        }
      }

      // Ground plane (visual)
      const groundGeo = new THREE.PlaneGeometry(worldSize.width * blockSize * 1.5, worldSize.depth * blockSize * 1.5);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x778899, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
      const groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.position.y = -blockSize / 2;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      // Cannon.js ground plane (physics)
      const groundPlaneShape = new CANNON.Plane();
      const groundPlaneBody = new CANNON.Body({
        mass: 0, // Static
        shape: groundPlaneShape,
        material: groundMaterial,
        position: new CANNON.Vec3(0, groundMesh.position.y, 0) // Match visual ground plane position
      });
      groundPlaneBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be horizontal
      world.addBody(groundPlaneBody);
    }

    function setupBlockSelector() {
      const selectorDiv = document.getElementById('block-selector');
      Object.keys(blockTypes).forEach((key) => {
        const type = blockTypes[key];
        const option = document.createElement('div');
        option.classList.add('block-option');
        option.textContent = key.substring(0, 4).toUpperCase(); // Show more letters
        option.style.backgroundColor = getBlockColor(type);
        if (type === blockTypes.WATER || type === blockTypes.LAVA || type === blockTypes.GLOWSTONE) {
          option.style.color = (type === blockTypes.GLOWSTONE) ? 'black' : 'white'; // Ensure visibility
        }
        option.title = key;
        option.dataset.blockType = type;
        if (type === currentBlockType) {
          option.classList.add('selected');
        }
        option.addEventListener('click', () => {
          currentBlockType = type;
          updateBlockSelectorUI();
        });
        selectorDiv.appendChild(option);
      });
    }

    function getBlockColor(type) { // Used for selector background
      switch (type) {
        case blockTypes.GRASS: return '#6A994E';
        case blockTypes.DIRT: return '#8C6A48';
        case blockTypes.STONE: return '#808080';
        case blockTypes.WOOD: return '#A0522D';
        case blockTypes.WATER: return 'rgba(50, 100, 200, 0.8)';
        case blockTypes.LAVA: return '#FF6000';
        case blockTypes.GLOWSTONE: return '#FFEE88';
        default: return '#FFFFFF';
      }
    }

    function updateBlockSelectorUI() {
      document.querySelectorAll('.block-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.blockType === currentBlockType);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      switch (event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space': moveUpAction = true; break;
        case 'ShiftLeft': moveDown = true; break;
        case 'Digit1': currentBlockType = blockTypes.GRASS; updateBlockSelectorUI(); break;
        case 'Digit2': currentBlockType = blockTypes.DIRT; updateBlockSelectorUI(); break;
        case 'Digit3': currentBlockType = blockTypes.STONE; updateBlockSelectorUI(); break;
        case 'Digit4': currentBlockType = blockTypes.WOOD; updateBlockSelectorUI(); break;
        case 'Digit5': currentBlockType = blockTypes.WATER; updateBlockSelectorUI(); break;
        case 'Digit6': currentBlockType = blockTypes.LAVA; updateBlockSelectorUI(); break;
        case 'Digit7': currentBlockType = blockTypes.GLOWSTONE; updateBlockSelectorUI(); break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyD': moveRight = false; break;
        case 'ShiftLeft': moveDown = false; break;
        case 'Space': moveUpAction = false; break; // Reset flag on key up
      }
    }

    function onMouseDown(event) {
      if (!controls.isLocked) return;

      pointer.set(0, 0); // Raycast from center of camera
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(worldObjects, false); // false for non-recursive

      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (event.button === 2 || event.ctrlKey) { // Right click or Ctrl+LeftClick to remove
          if (intersect.object.userData.blockType && intersect.object.userData.cannonBody) {
            // Remove light source if any
            if (intersect.object.userData.light) {
              scene.remove(intersect.object.userData.light);
              intersect.object.userData.light = null; // Clear reference
            }

            world.removeBody(intersect.object.userData.cannonBody);
            scene.remove(intersect.object);
            worldObjects.splice(worldObjects.indexOf(intersect.object), 1);

            // Dispose Three.js resources
            if (intersect.object.geometry) intersect.object.geometry.dispose();
            if (intersect.object.material) {
              const material = intersect.object.material;
              if (Array.isArray(material)) {
                material.forEach(m => {
                  if (m.map) m.map.dispose();
                  m.dispose();
                });
              } else {
                if (material.map) material.map.dispose();
                material.dispose();
              }
            }
          }
        } else if (event.button === 0) { // Left click to place
          const placementPosition = new THREE.Vector3();
          placementPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, blockSize);

          const newBlockHalfExtents = new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2);
          const newBlockAABB = new CANNON.AABB({
            lowerBound: new CANNON.Vec3(placementPosition.x - newBlockHalfExtents.x, placementPosition.y - newBlockHalfExtents.y, placementPosition.z - newBlockHalfExtents.z),
            upperBound: new CANNON.Vec3(placementPosition.x + newBlockHalfExtents.x, placementPosition.y + newBlockHalfExtents.y, placementPosition.z + newBlockHalfExtents.z)
          });

          playerBody.computeAABB();
          if (newBlockAABB.overlaps(playerBody.aabb)) {
            console.log("Cannot place block: intersects player.");
            return;
          }

          let blockExists = worldObjects.some(obj => obj.position.distanceTo(placementPosition) < 0.1);
          if (!blockExists) {
            const newBlockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const newBlockMaterial = blockMaterials[currentBlockType] || blockMaterials[blockTypes.STONE];
            // For materials like water/lava with DoubleSide or unique emissive, cloning is good.
            // For standard blocks, it might not be necessary if they don't change instance properties.
            const newBlockMesh = new THREE.Mesh(newBlockGeometry, newBlockMaterial);
            newBlockMesh.position.copy(placementPosition);
            newBlockMesh.castShadow = true;
            newBlockMesh.receiveShadow = true;
            newBlockMesh.userData.blockType = currentBlockType;
            scene.add(newBlockMesh);
            worldObjects.push(newBlockMesh);

            const newBlockShape = new CANNON.Box(newBlockHalfExtents);
            const newBlockBody = new CANNON.Body({
              mass: 0,
              shape: newBlockShape,
              position: new CANNON.Vec3(newBlockMesh.position.x, newBlockMesh.position.y, newBlockMesh.position.z),
              material: groundMaterial
            });

            // Fluid / Sensor logic
            if (currentBlockType === blockTypes.WATER || currentBlockType === blockTypes.LAVA) {
              newBlockBody.collisionResponse = 0; // Make it a sensor
              newBlockBody.userData = { blockType: currentBlockType }; // Store type for sensor logic
            }
            // Light source logic
            if (currentBlockType === blockTypes.GLOWSTONE || currentBlockType === blockTypes.LAVA) {
              const light = new THREE.PointLight(0xffffff, 0, 8);
              light.position.copy(newBlockMesh.position);
              if (currentBlockType === blockTypes.GLOWSTONE) {
                light.color.setHex(0xffffdd);
                light.intensity = 0.7;
                light.distance = 7;
              } else { // LAVA
                light.color.setHex(0xff7700);
                light.intensity = 0.6;
                light.distance = 6;
              }
              scene.add(light);
              newBlockMesh.userData.light = light;
            }

            world.addBody(newBlockBody);
            newBlockMesh.userData.cannonBody = newBlockBody;
          }
        }
      }
    }

    const direction = new THREE.Vector3(); // For movement calculation
    const FWD = new THREE.Vector3(0, 0, -1);
    const RIGHT = new THREE.Vector3(1, 0, 0);

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      // Step the physics world
      if (world) {
        world.step(timeStep, delta, 3); // fixed timestep, time since last frame, max sub-steps
      }

      if (controls.isLocked) {
        const playerObject = controls.getObject(); // This is the THREE.Object3D for the player (camera parent)

        let currentSpeed = playerSpeed;
        let targetVelocityY = playerBody.velocity.y; // Start with current Y velocity (affected by gravity from world.step)

        if (isInWater) {
          currentSpeed *= waterProperties.speedFactor;
          if (moveUpAction) { // Swimming up
            targetVelocityY = waterProperties.swimUpVelocity;
          } else if (moveDown) { // Swimming down
            targetVelocityY = waterProperties.swimDownVelocity;
          }
          // if neither, targetVelocityY remains (gravity & damping will act via world.step)
        } else { // Not in water
          if (moveUpAction && canJump) {
            targetVelocityY = jumpVelocity;
            canJump = false; // Consume jump
          } else if (moveDown) { // Creative fly down
            targetVelocityY = -playerSpeed;
            canJump = false; // Cannot jump while actively flying down
          }
        }

        // If moveUpAction was intended for jump/swim and conditions met, it's been used.
        // If it was pressed but conditions (isInWater or canJump) weren't met, it will remain true.
        // We reset moveUpAction on keyup. So here, if it was true and led to an action,
        // it should ideally be reset. Let's ensure it's consumed if it caused a Y velocity change.
        if (moveUpAction && ((isInWater) || (!isInWater && canJump))) {
          // If we just set targetVelocityY due to moveUpAction
          // No need to explicitly set moveUpAction = false here, as keyup handles it.
          // The problem is if space is HELD, moveUpAction stays true.
          // For jump, this is fine (one impulse). For swim, continuous force would be better.
          // Current setup: press space = one burst of upward velocity for swim.
        }


        playerBody.velocity.y = targetVelocityY;

        // Horizontal movement
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.z = Number(moveForward) - Number(moveBackward);

        // Reset XZ velocity before applying new input
        playerBody.velocity.x = 0;
        playerBody.velocity.z = 0;

        if (direction.x !== 0 || direction.z !== 0) {
          FWD.set(0, 0, -1).applyQuaternion(playerObject.quaternion);
          RIGHT.set(1, 0, 0).applyQuaternion(playerObject.quaternion);

          const moveDir = new THREE.Vector3(
            RIGHT.x * direction.x + FWD.x * direction.z,
            0, // Movement is planar
            RIGHT.z * direction.x + FWD.z * direction.z
          ).normalize();

          playerBody.velocity.x = moveDir.x * currentSpeed;
          playerBody.velocity.z = moveDir.z * currentSpeed;
        }

        // Sync Three.js player object to Cannon.js body position
        playerObject.position.copy(playerBody.position);

        // Fall off world
        if (playerBody.position.y < -30) {
          playerBody.position.set(worldSize.width / 4, worldSize.height + 10, worldSize.depth / 4);
          playerBody.velocity.set(0, 0, 0);
          canJump = false; // Reset jump state
          if (isInWater) { waterContactCount = 0; exitWater(); } // Reset water state if falling out
        }
      }

      renderer.render(scene, camera);
    }

  </script>
</body>

</html>