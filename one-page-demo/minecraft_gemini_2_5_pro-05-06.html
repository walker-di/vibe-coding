<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniCraft.js - Split-Screen</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #instructions {
      width: 80%;
      max-width: 600px;
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: center;
      color: white;
      background-color: rgba(50, 50, 50, 0.8);
      border-radius: 10px;
      max-height: 90vh;
      overflow-y: auto;
    }

    #instructions p:first-of-type {
      cursor: pointer;
      font-weight: bold;
    }

    /* Make sure cursor changes for all clickable buttons/elements */
    #instructions p:first-of-type:hover,
    button:hover,
    .block-option:hover {
      opacity: 0.9;
    }


    .crosshair {
      position: absolute;
      width: 2px;
      height: 10px;
      background-color: white;
      transform: translate(-50%, -50%);
      pointer-events: none;
      mix-blend-mode: difference;
      display: none;
      /* Initially hidden */
    }

    .crosshair::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -4px;
      width: 10px;
      height: 2px;
      background-color: white;
      transform: translateY(-50%);
    }

    #crosshairP1 {
      /* ID for Player 1's crosshair */
    }

    #crosshairP2 {
      /* ID for Player 2's crosshair */
    }


    #block-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      /* Changed to flex by default, controlled by JS */
      gap: 10px;
      z-index: 10;
      /* Ensure it's above viewports */
    }

    .block-option {
      width: 40px;
      height: 40px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      user-select: none;
      font-size: 10px;
    }

    .block-option.selected {
      border-color: white;
      box-shadow: 0 0 10px cyan;
    }

    #save-load-ui {
      margin-top: 20px;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 8px;
      text-align: left;
    }

    #save-load-ui h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    #save-load-ui input[type="text"],
    #save-load-ui select {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #666;
      background-color: #444;
      color: white;
      margin-bottom: 10px;
      box-sizing: border-box;
      width: calc(100% - 110px);
      /* Adjust width based on button */
    }

    #save-load-ui select {
      width: 100%;
      /* Select can be full width */
    }

    #save-load-ui button {
      padding: 8px 12px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      min-width: 80px;
      /* Ensure buttons have a decent min width */
      box-sizing: border-box;
    }

    #save-load-ui button:hover {
      background-color: #777;
    }

    .save-load-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
      flex-wrap: wrap;
      /* Allow wrap on small screens */
    }

    .save-load-row input[type="text"] {
      flex-grow: 1;
      min-width: 150px;
      /* Prevent input from becoming too small */
    }

    .world-management-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .world-management-row select {
      flex-grow: 1;
      min-height: 100px;
    }

    .world-management-buttons {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .world-management-buttons button {
      width: 100%;
    }

    /* Styles for Game Mode Selector */
    #game-mode-selector {
      margin-top: 20px;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }

    .game-mode-button {
      padding: 10px 15px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      flex-grow: 1;
      /* Make buttons share space */
    }

    .game-mode-button:hover {
      background-color: #777;
    }

    .game-mode-button.selected {
      background-color: #007bff;
      /* A highlight color */
      box-shadow: 0 0 8px #007bff;
    }

    #tagInstructions {
      font-size: 0.9em;
      color: #eee;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 8px;
      border-radius: 4px;
      margin-top: 10px;
      text-align: left;
      /* Better for list */
    }


    /* Styles for Player Status Display (Tag Mode) */
    .player-status-display {
      position: absolute;
      top: 10px;
      /* left and width will be set by JS per viewport */
      padding: 8px 12px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      border-radius: 5px;
      z-index: 100;
      /* Above crosshairs */
      display: none;
      /* Hidden initially */
      text-align: center;
      /* Center text within the display */
      pointer-events: none;
      /* Prevent interaction */
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <h1>MiniCraft.js - Split Screen</h1>
      <p id="playButton">Click to play</p>
      <p>
        <b>Player 1 (Left Screen):</b><br>
        WASD: Move<br>Space: Jump / Swim Up<br>Shift: Descend / Swim Down<br>Mouse: Look<br>Left Click: Place
        Block (Creative Mode)<br>Right Click: Remove Block (Creative Mode)<br>1-7: Select Block Type (Creative Mode)
      </p>
      <p>
        <b>Player 2 (Right Screen):</b><br>
        IJKL: Move<br>U: Jump / Swim Up<br>H: Descend / Swim Down<br>Arrow Keys: Look Around<br>O: Place Block (Creative
        Mode)<br>P:
        Remove Block (Creative Mode)<br>(Block type shared with Player 1, Creative Mode)
      </p>

      <div id="game-mode-selector">
        <h3>Select Game Mode:</h3>
        <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
          <button id="creativeModeButton" class="game-mode-button selected">Creative Mode</button>
          <button id="tagModeButton" class="game-mode-button">Tag Mode</button>
        </div>
        <div id="tagInstructions" style="display: none;">
          <b>Tag Mode Rules:</b><br>
          One player is "IT" (indicator is <span style="color:red; font-weight:bold;">RED</span>). Try to tag the other
          player (indicator <span style="color:lightgreen; font-weight:bold;">GREEN</span>)!<br>
          When tagged, roles switch! There's a short cooldown after each tag.<br>
          Block placement/removal is disabled in Tag Mode.
        </div>
      </div>

      <div id="save-load-ui" style="display: none;">
        <h3>Save Current World</h3>
        <div class="save-load-row">
          <input type="text" id="worldNameInput" placeholder="World Name">
          <button id="saveWorldButton">Save</button>
        </div>
        <hr style="margin: 15px 0; border-color: #666;">
        <h3>Manage Worlds</h3>
        <div class="world-management-row">
          <select id="worldListSelect" size="5"></select>
          <div class="world-management-buttons">
            <button id="loadWorldButton">Load</button>
            <button id="deleteWorldButton">Delete</button>
          </div>
        </div>
        <button id="newWorldButton" style="width: 100%; margin-top: 10px;">Create New Procedural World</button>
      </div>
    </div>
  </div>

  <div id="crosshairP1" class="crosshair"></div>
  <div id="crosshairP2" class="crosshair"></div>
  <div id="block-selector"></div>

  <!-- Player Status Displays for Tag Mode -->
  <div id="player1Status" class="player-status-display"></div>
  <div id="player2Status" class="player-status-display"></div>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, renderer, world;
    let worldObjects = [];

    const NUM_PLAYERS = 2;
    const players = []; // Array to hold player data

    const timeStep = 1 / 60;
    let playerMaterial, groundMaterial, playerGroundContactMaterial;

    const worldSize = { width: 20, depth: 20, height: 10 };
    const blockSize = 1;

    const playerHeight = 1.8;
    const playerRadius = 0.4;
    const playerSpeed = 5.0;
    const jumpVelocity = 7.0;
    const initialGravity = 20.0;

    const blockTypes = {
      GRASS: 'grass', DIRT: 'dirt', STONE: 'stone', WOOD: 'wood',
      WATER: 'water', LAVA: 'lava', GLOWSTONE: 'glowstone'
    };
    let currentBlockType = blockTypes.GRASS;
    const blockMaterials = {};

    let lastTime = performance.now();

    const originalGravityY = -initialGravity;
    const waterProperties = {
      gravityFactor: 0.3, speedFactor: 0.5, damping: 0.9,
      swimUpVelocity: 4.0, swimDownVelocity: -4.0
    };
    const originalPlayerDamping = 0.3;

    let db;
    const DB_NAME = 'MiniCraftWorldsDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'worlds';
    let initialGroundMesh, initialGroundBody;

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Tag Game Variables
    let gameMode = 'creative'; // 'creative' or 'tag'
    let itPlayerId = -1; // Player ID of who is "It"
    let tagCooldown = 0; // Cooldown in seconds after a tag
    const TAG_COOLDOWN_DURATION = 3; // 3 seconds
    let tagGameActive = false;


    function openDB() {
      return new Promise((resolve, reject) => {
        if (db) {
          resolve(db);
          return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (event) => reject("IndexedDB error: " + event.target.errorCode);
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };
        request.onupgradeneeded = (event) => {
          event.target.result.createObjectStore(STORE_NAME, { keyPath: 'name' });
        };
      });
    }
    async function saveWorldDB(worldName, worldData) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ name: worldName, data: worldData });
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject("Save error: " + event.target.error);
      });
    }
    async function loadWorldDB(worldName) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(worldName);
        request.onsuccess = (event) => resolve(event.target.result ? event.target.result.data : null);
        request.onerror = (event) => reject("Load error: " + event.target.error);
      });
    }
    async function getAllWorldNamesDB() {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAllKeys();
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject("Error fetching world names: " + event.target.error);
      });
    }
    async function deleteWorldDB(worldName) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(worldName);
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject("Delete error: " + event.target.error);
      });
    }

    init(); // Start the engine

    //----------------------------------------------------------------
    // TEXTURES and MATERIALS
    //----------------------------------------------------------------
    function createTexture(color, text = null, isFluid = false) {
      const canvas = document.createElement('canvas');
      canvas.width = 64; canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.fillRect(0, 0, 64, 64);
      if (!isFluid) {
        context.strokeStyle = 'rgba(0,0,0,0.2)'; context.lineWidth = 2;
        context.strokeRect(1, 1, 62, 62);
      }
      if (text) {
        context.fillStyle = isFluid ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.5)';
        context.font = '10px Arial'; context.textAlign = 'center';
        context.textBaseline = 'middle'; context.fillText(text, 32, 32);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    function initMaterials() {
      const grassTopTexture = createTexture('#6A994E');
      const grassSideTexture = createTexture('#A7C957');
      const dirtTexture = createTexture('#8C6A48');
      const stoneTexture = createTexture('#808080');
      const woodTexture = createTexture('#A0522D');
      const waterTexture = createTexture('rgba(50, 100, 200, 0.6)', null, true);
      const lavaTexture = createTexture('#FF6000', null, true);
      const glowstoneTexture = createTexture('#FFEE88', 'GLOW');

      blockMaterials[blockTypes.GRASS] = [
        grassSideTexture, grassSideTexture, grassTopTexture, dirtTexture, grassSideTexture, grassSideTexture
      ].map(texture => new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 }));
      blockMaterials[blockTypes.DIRT] = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9, metalness: 0 });
      blockMaterials[blockTypes.STONE] = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.2 });
      blockMaterials[blockTypes.WOOD] = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
      blockMaterials[blockTypes.WATER] = new THREE.MeshStandardMaterial({
        map: waterTexture, transparent: true, opacity: 0.6, roughness: 0.2, metalness: 0.0, side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.LAVA] = new THREE.MeshStandardMaterial({
        map: lavaTexture, roughness: 0.8, metalness: 0.2,
        emissive: new THREE.Color(0xdd4400), emissiveIntensity: 0.8, side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.GLOWSTONE] = new THREE.MeshStandardMaterial({
        map: glowstoneTexture, roughness: 0.9, metalness: 0.1,
        emissive: new THREE.Color(0xffffaa), emissiveIntensity: 0.9
      });
    }
    //----------------------------------------------------------------
    // PLAYER SETUP
    //----------------------------------------------------------------
    function createPlayerDirectionIndicatorMesh() {
      const length = 0.5; const baseWidth = 0.3; const prismHeight = 0.1;
      const shape = new THREE.Shape();
      shape.moveTo(length, 0); shape.lineTo(0, baseWidth / 2); shape.lineTo(0, -baseWidth / 2); shape.closePath();
      const extrudeSettings = { depth: prismHeight, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.rotateX(Math.PI / 2); geometry.rotateY(-Math.PI / 2); geometry.translate(0, prismHeight / 2, 0); // Center geometry base
      const material = new THREE.MeshStandardMaterial({
        color: 0xffA500, emissive: 0xcc8400, roughness: 0.7, metalness: 0.2,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      return mesh;
    }

    //----------------------------------------------------------------
    // INITIALIZATION
    //----------------------------------------------------------------
    async function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 10, 75);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setScissorTest(true);
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 80, 30); directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 200;
      const shadowCamSize = 30;
      directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize;
      scene.add(directionalLight);

      initMaterials();
      await openDB();

      world = new CANNON.World();
      world.gravity.set(0, -initialGravity, 0);
      world.broadphase = new CANNON.NaiveBroadphase();

      playerMaterial = new CANNON.Material("playerMaterial");
      groundMaterial = new CANNON.Material("groundMaterial");
      playerGroundContactMaterial = new CANNON.ContactMaterial(playerMaterial, groundMaterial, { friction: 0.0, restitution: 0.0 });
      world.addContactMaterial(playerGroundContactMaterial);

      for (let i = 0; i < NUM_PLAYERS; i++) {
        const player = {
          id: i,
          camera: new THREE.PerspectiveCamera(75, (window.innerWidth / NUM_PLAYERS) / window.innerHeight, 0.1, 1000),
          body: null, controls: null, yawObject: null, pitchObject: new THREE.Object3D(),
          directionIndicator: createPlayerDirectionIndicatorMesh(),
          crosshairElement: document.getElementById(i === 0 ? 'crosshairP1' : 'crosshairP2'),
          tagStatusElement: document.getElementById(i === 0 ? 'player1Status' : 'player2Status'),
          isIt: false,

          moveForward: false, moveBackward: false, moveLeft: false, moveRight: false,
          moveUpAction: false, moveDownAction: false,
          lookLeft: false, lookRight: false, lookUp: false, lookDown: false,
          actionPlace: false, actionRemove: false,

          canJump: false, isInWater: false, waterContactCount: 0,
          targetYaw: 0, targetPitch: 0, currentYaw: 0, currentPitch: 0,
        };

        player.camera.position.y = playerHeight * 0.4;
        player.pitchObject.add(player.camera);

        if (i === 0) {
          player.controls = new PointerLockControls(player.camera, document.body);
          player.yawObject = player.controls.getObject();
        } else {
          player.yawObject = new THREE.Object3D();
          player.yawObject.add(player.pitchObject);
        }
        scene.add(player.yawObject);
        scene.add(player.directionIndicator);
        player.directionIndicator.visible = false; // Initially hidden

        const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius));
        const initialPlayerPos = new THREE.Vector3(
          worldSize.width / 4 + (i * blockSize * 5) - (blockSize * 2.5 * (NUM_PLAYERS - 1) / 2), // Use the more spread out spawn
          worldSize.height + 2, // Spawn high enough
          worldSize.depth / 4
        );
        player.body = new CANNON.Body({
          mass: 70, position: new CANNON.Vec3(initialPlayerPos.x, initialPlayerPos.y, initialPlayerPos.z),
          shape: playerShape, material: playerMaterial, fixedRotation: true, linearDamping: originalPlayerDamping
        });
        world.addBody(player.body);
        player.yawObject.position.copy(player.body.position);

        player.body.userData = { playerId: i }; // Important for collision checks

        // --- Player Collision Listeners ---
        player.body.addEventListener("collide", (event) => {
          const contact = event.contact; const upAxis = new CANNON.Vec3(0, 1, 0);
          let contactNormal = new CANNON.Vec3();
          if (contact.bi.id === player.body.id) contact.ni.negate(contactNormal);
          else contactNormal.copy(contact.ni);

          // Ground contact for jumping
          if (contactNormal.dot(upAxis) > 0.5) {
            const otherBody = (contact.bi.id === player.body.id) ? contact.bj : contact.bi;
            if (otherBody.mass === 0 && otherBody.collisionResponse !== 0 && (!otherBody.userData || otherBody.userData.playerId === undefined)) {
              if (!player.isInWater) player.canJump = true;
            }
          }

          // Tagging logic on collision
          if (tagGameActive && tagCooldown <= 0 && NUM_PLAYERS >= 2) {
            const thisPlayerBody = player.body;
            const otherBodyInCollision = (event.bodyA.id === thisPlayerBody.id) ? event.bodyB : event.bodyA;
            if (otherBodyInCollision.userData && typeof otherBodyInCollision.userData.playerId !== 'undefined') {
              const thisPlayer = players[thisPlayerBody.userData.playerId];
              const otherPlayer = players[otherBodyInCollision.userData.playerId];
              if (thisPlayer && otherPlayer && thisPlayer.id !== otherPlayer.id) {
                if (thisPlayer.isIt && !otherPlayer.isIt) switchItPlayer(thisPlayer.id, otherPlayer.id);
                else if (!thisPlayer.isIt && otherPlayer.isIt) switchItPlayer(otherPlayer.id, thisPlayer.id);
              }
            }
          }
        });
        player.body.addEventListener("beginContact", (event) => {
          const otherBody = event.bodyA.id === player.body.id ? event.bodyB : event.bodyA;
          if (otherBody.collisionResponse === 0 && otherBody.userData) {
            if (otherBody.userData.blockType === blockTypes.WATER) enterWater(player);
            else if (otherBody.userData.blockType === blockTypes.LAVA) enterLava(player);
          }
        });
        player.body.addEventListener("endContact", (event) => {
          const otherBody = event.bodyA.id === player.body.id ? event.bodyB : event.bodyA;
          if (otherBody.collisionResponse === 0 && otherBody.userData) {
            if (otherBody.userData.blockType === blockTypes.WATER) exitWater(player);
          }
        });
        // --- End Player Collision Listeners ---

        players.push(player);
      }

      // --- Initial Ground ---
      const groundGeo = new THREE.PlaneGeometry(worldSize.width * blockSize * 2, worldSize.depth * blockSize * 2);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x607D3B, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
      initialGroundMesh = new THREE.Mesh(groundGeo, groundMat);
      initialGroundMesh.rotation.x = -Math.PI / 2;
      initialGroundMesh.position.y = -blockSize / 2 + 0.01;
      initialGroundMesh.receiveShadow = true;
      scene.add(initialGroundMesh);

      const groundPlaneShape = new CANNON.Plane();
      initialGroundBody = new CANNON.Body({
        mass: 0, shape: groundPlaneShape, material: groundMaterial,
        position: new CANNON.Vec3(0, -blockSize / 2, 0)
      });
      initialGroundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      world.addBody(initialGroundBody);
      // --- End Initial Ground ---

      setupUIAndEventListeners();
      setupBlockSelector();
      updateGameModeUI(); // Set initial UI state based on default gameMode

      clearWorld(); // Clear any test blocks
      if (initialGroundMesh) initialGroundMesh.visible = true; // Ensure base ground is visible
      resetPlayersToSpawn(); // Set initial player positions
      generateWorld();      // Generate procedural world
      animate();            // Start the loop
    }

    //----------------------------------------------------------------
    // PLAYER STATE / RESPAWN / ENVIRONMENT INTERACTION
    //----------------------------------------------------------------

    function resetPlayersToSpawn(playerToReset = null) {
      // If a specific player is passed, reset only them; otherwise, reset all
      const playersToUpdate = playerToReset ? [playerToReset] : players;

      playersToUpdate.forEach((player, iOriginal) => {
        // Use the player's actual ID for consistent spawn points
        const playerIndex = player.id;
        const spawnPos = new THREE.Vector3(
          worldSize.width / 4 + (playerIndex * blockSize * 5) - (blockSize * 2.5 * (NUM_PLAYERS - 1) / 2),
          worldSize.height + 3, // Spawn high enough to avoid instant ground collision issues
          worldSize.depth / 4
        );
        player.body.position.copy(spawnPos);
        player.body.velocity.set(0, 0, 0);
        player.body.angularVelocity.set(0, 0, 0);
        player.body.quaternion.set(0, 0, 0, 1); // Reset body rotation

        player.yawObject.position.copy(player.body.position);
        player.yawObject.quaternion.set(0, 0, 0, 1);
        player.pitchObject.quaternion.set(0, 0, 0, 1);
        player.currentYaw = 0; player.currentPitch = 0; player.targetYaw = 0; player.targetPitch = 0;

        player.isInWater = false; player.waterContactCount = 0; player.canJump = false;
        player.isIt = false; // Always reset 'It' status on spawn
      });

      // Only adjust global physics/damping if resetting ALL players
      if (!playerToReset) {
        if (!players.some(p => p.isInWater)) { world.gravity.set(0, originalGravityY, 0); }
        players.forEach(p => p.body.linearDamping = originalPlayerDamping);
      }
      else { // If resetting only one player
        playerToReset.body.linearDamping = originalPlayerDamping;
        // Ensure gravity resets if no one is in water anymore
        if (!players.some(p => p.isInWater)) world.gravity.set(0, originalGravityY, 0);
      }
    }

    function enterWater(player) {
      player.waterContactCount++;
      if (!player.isInWater && player.waterContactCount > 0) {
        player.isInWater = true;
        world.gravity.set(0, originalGravityY * waterProperties.gravityFactor, 0);
        player.body.linearDamping = waterProperties.damping;
      }
    }
    function exitWater(player) {
      player.waterContactCount--;
      if (player.isInWater && player.waterContactCount <= 0) {
        player.isInWater = false; player.waterContactCount = 0;
        const anyPlayerInWater = players.some(p => p.isInWater);
        if (!anyPlayerInWater) { // Reset gravity ONLY if NO players are in water
          world.gravity.set(0, originalGravityY, 0);
        }
        player.body.linearDamping = originalPlayerDamping; // Reset this player's damping
      }
    }

    function enterLava(player) {
      console.warn(`Player ${player.id} entered lava. Respawning.`);
      if (player.isInWater) { exitWater(player); } // Exit water state before respawn

      const wasIt = player.isIt; // Check if they were IT *before* respawning

      resetPlayersToSpawn(player); // Respawn only this player (also sets player.isIt to false)

      // If in tag mode, and this player was "IT", reassign "IT" status
      if (tagGameActive && wasIt && NUM_PLAYERS > 1) {
        let newItCandidateId = (player.id + 1) % NUM_PLAYERS; // Simplistic: next player
        switchItPlayer(player.id, newItCandidateId, true); // Pass true to indicate it's a forced switch (no tag needed)
        console.log(`Player ${player.id} fell in lava while "IT". Player ${newItCandidateId + 1} is now IT.`);
      }
    }

    //----------------------------------------------------------------
    // WORLD GENERATION AND BLOCK MANAGEMENT
    //----------------------------------------------------------------
    function generateWorld() {
      const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      for (let x = 0; x < worldSize.width; x++) {
        for (let z = 0; z < worldSize.depth; z++) {
          const groundLevel = Math.floor(worldSize.height / 3);
          const height = groundLevel + Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let material; let blockType;
            if (y === height - 1 && y >= groundLevel) { material = blockMaterials[blockTypes.GRASS]; blockType = blockTypes.GRASS; }
            else if (y < height - 1 && y >= groundLevel - 2) { material = blockMaterials[blockTypes.DIRT]; blockType = blockTypes.DIRT; }
            else { material = blockMaterials[blockTypes.STONE]; blockType = blockTypes.STONE; }

            const blockPos = new THREE.Vector3(
              x * blockSize - (worldSize.width * blockSize / 2) + blockSize / 2,
              y * blockSize + blockSize / 2,
              z * blockSize - (worldSize.depth * blockSize / 2) + blockSize / 2
            );
            addBlockInternal(blockPos, blockType, material, boxGeometry);
          }
        }
      }
      if (initialGroundMesh) initialGroundMesh.visible = false; // Hide the infinite plane if blocks are generated
    }

    function addBlockInternal(position, type, material, geometry) {
      const blockMesh = new THREE.Mesh(geometry, material);
      blockMesh.position.copy(position);
      blockMesh.castShadow = true;
      blockMesh.receiveShadow = true;
      blockMesh.userData.blockType = type;
      scene.add(blockMesh);
      worldObjects.push(blockMesh);

      const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2));
      const blockBody = new CANNON.Body({
        mass: 0, shape: blockShape,
        position: new CANNON.Vec3(blockMesh.position.x, blockMesh.position.y, blockMesh.position.z),
        material: groundMaterial
      });

      if (type === blockTypes.WATER || type === blockTypes.LAVA) {
        blockBody.collisionResponse = 0; // No physical collision, but triggers events
        blockBody.userData = { blockType: type }; // Needed for contact events
      }
      if (type === blockTypes.GLOWSTONE || type === blockTypes.LAVA) {
        const light = new THREE.PointLight(0xffffff, 0, 8);
        light.position.copy(blockMesh.position);
        if (type === blockTypes.GLOWSTONE) { light.color.setHex(0xffffdd); light.intensity = 0.7; light.distance = 7; }
        else { light.color.setHex(0xff7700); light.intensity = 0.6; light.distance = 6; }
        scene.add(light);
        blockMesh.userData.light = light; // Store reference to remove it later
      }
      world.addBody(blockBody);
      blockMesh.userData.cannonBody = blockBody; // Store reference to remove it later
      return blockMesh;
    }

    function removeBlockByMesh(blockMesh) {
      if (!blockMesh || !blockMesh.userData) return; // Safety check

      if (blockMesh.userData.light) {
        scene.remove(blockMesh.userData.light);
        blockMesh.userData.light.dispose(); // Dispose light resources
        blockMesh.userData.light = null;
      }
      if (blockMesh.userData.cannonBody) {
        world.removeBody(blockMesh.userData.cannonBody);
        blockMesh.userData.cannonBody = null;
      }
      scene.remove(blockMesh);
      const index = worldObjects.indexOf(blockMesh);
      if (index > -1) worldObjects.splice(index, 1);

      // Dispose geometry and material to free memory
      if (blockMesh.geometry) blockMesh.geometry.dispose();
      if (blockMesh.material) {
        const material = blockMesh.material;
        if (Array.isArray(material)) {
          material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
        } else { if (material.map) material.map.dispose(); material.dispose(); }
      }
    }


    //----------------------------------------------------------------
    // UI and EVENT LISTENERS
    //----------------------------------------------------------------

    function setupBlockSelector() {
      const selectorDiv = document.getElementById('block-selector');
      selectorDiv.innerHTML = ''; // Clear previous options
      Object.keys(blockTypes).forEach((key) => {
        const type = blockTypes[key];
        const option = document.createElement('div');
        option.classList.add('block-option');
        option.textContent = key.substring(0, 4).toUpperCase();
        option.style.backgroundColor = getBlockColor(type);
        if (type === blockTypes.WATER || type === blockTypes.LAVA || type === blockTypes.GLOWSTONE) {
          option.style.color = (type === blockTypes.GLOWSTONE) ? 'black' : 'white';
        }
        option.title = key; option.dataset.blockType = type;
        if (type === currentBlockType) option.classList.add('selected');
        option.addEventListener('click', () => { currentBlockType = type; updateBlockSelectorUI(); });
        selectorDiv.appendChild(option);
      });
    }
    function getBlockColor(type) {
      switch (type) {
        case blockTypes.GRASS: return '#6A994E'; case blockTypes.DIRT: return '#8C6A48';
        case blockTypes.STONE: return '#808080'; case blockTypes.WOOD: return '#A0522D';
        case blockTypes.WATER: return 'rgba(50, 100, 200, 0.8)'; case blockTypes.LAVA: return '#FF6000';
        case blockTypes.GLOWSTONE: return '#FFEE88'; default: return '#FFFFFF';
      }
    }
    function updateBlockSelectorUI() {
      document.querySelectorAll('.block-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.blockType === currentBlockType);
      });
    }

    function onWindowResize() {
      players.forEach(player => {
        player.camera.aspect = (window.innerWidth / NUM_PLAYERS) / window.innerHeight;
        player.camera.updateProjectionMatrix();
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateCrosshairPositions();
      // Update tag status display positions if tag game is active
      if (tagGameActive) {
        players.forEach(player => updatePlayerTagVisuals(player, true)); // Pass true for resize
      }
    }
    function updateCrosshairPositions() {
      players.forEach((player, i) => {
        if (player.crosshairElement) {
          const viewportWidth = window.innerWidth / NUM_PLAYERS;
          const viewportX = i * viewportWidth;
          player.crosshairElement.style.left = `${viewportX + viewportWidth / 2}px`;
          player.crosshairElement.style.top = `${window.innerHeight / 2}px`;
        }
      });
    }


    function onKeyDown(event) {
      // Prevent key input if focused on text input/select, unless it's an essential game key maybe (e.g. Esc)
      if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "SELECT") {
        return;
      }

      switch (event.code) {
        case 'KeyW': players[0].moveForward = true; break;
        case 'KeyA': players[0].moveLeft = true; break;
        case 'KeyS': players[0].moveBackward = true; break;
        case 'KeyD': players[0].moveRight = true; break;
        case 'Space': players[0].moveUpAction = true; break;
        case 'ShiftLeft': players[0].moveDownAction = true; break;
      }
      // Block selection only in creative mode
      if (gameMode === 'creative') {
        switch (event.code) {
          case 'Digit1': currentBlockType = blockTypes.GRASS; updateBlockSelectorUI(); break;
          case 'Digit2': currentBlockType = blockTypes.DIRT; updateBlockSelectorUI(); break;
          case 'Digit3': currentBlockType = blockTypes.STONE; updateBlockSelectorUI(); break;
          case 'Digit4': currentBlockType = blockTypes.WOOD; updateBlockSelectorUI(); break;
          case 'Digit5': currentBlockType = blockTypes.WATER; updateBlockSelectorUI(); break;
          case 'Digit6': currentBlockType = blockTypes.LAVA; updateBlockSelectorUI(); break;
          case 'Digit7': currentBlockType = blockTypes.GLOWSTONE; updateBlockSelectorUI(); break;
        }
      }

      // Player 2 Controls
      switch (event.code) {
        case 'KeyI': players[1].moveForward = true; break;
        case 'KeyJ': players[1].moveLeft = true; break;
        case 'KeyK': players[1].moveBackward = true; break;
        case 'KeyL': players[1].moveRight = true; break;
        case 'KeyU': players[1].moveUpAction = true; break;
        case 'KeyH': players[1].moveDownAction = true; break;
        case 'ArrowUp': players[1].lookUp = true; break;
        case 'ArrowDown': players[1].lookDown = true; break;
        case 'ArrowLeft': players[1].lookLeft = true; break;
        case 'ArrowRight': players[1].lookRight = true; break;
        case 'KeyO': if (gameMode === 'creative') players[1].actionPlace = true; break; // Creative only
        case 'KeyP': if (gameMode === 'creative') players[1].actionRemove = true; break; // Creative only
      }
    }

    function onKeyUp(event) {
      // Check active element again in case focus changed
      if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "SELECT") {
        return;
      }
      switch (event.code) {
        case 'KeyW': players[0].moveForward = false; break;
        case 'KeyA': players[0].moveLeft = false; break;
        case 'KeyS': players[0].moveBackward = false; break;
        case 'KeyD': players[0].moveRight = false; break;
        case 'ShiftLeft': players[0].moveDownAction = false; break;
        case 'Space': players[0].moveUpAction = false; break;
      }
      switch (event.code) {
        case 'KeyI': players[1].moveForward = false; break;
        case 'KeyJ': players[1].moveLeft = false; break;
        case 'KeyK': players[1].moveBackward = false; break;
        case 'KeyL': players[1].moveRight = false; break;
        case 'KeyU': players[1].moveUpAction = false; break;
        case 'KeyH': players[1].moveDownAction = false; break;
        case 'ArrowUp': players[1].lookUp = false; break;
        case 'ArrowDown': players[1].lookDown = false; break;
        case 'ArrowLeft': players[1].lookLeft = false; break;
        case 'ArrowRight': players[1].lookRight = false; break;
        case 'KeyO': players[1].actionPlace = false; break; // Always set to false on keyup
        case 'KeyP': players[1].actionRemove = false; break; // Always set to false on keyup
      }
    }

    function onMouseDown(event) {
      if (gameMode === 'tag') return; // No block interaction in tag mode

      const player = players[0];
      if (!player.controls || !player.controls.isLocked) return; // Only when locked and has controls
      handleBlockInteraction(player, event.button); // event.button: 0=Left, 1=Middle, 2=Right
    }

    //----------------------------------------------------------------
    // GAME ACTIONS (Placing/Removing blocks)
    //----------------------------------------------------------------

    function handlePlayerKeyboardActions(player) {
      // Only allow in creative mode
      if (gameMode === 'tag') return;

      if (player.actionPlace) {
        handleBlockInteraction(player, 0); // 0 for Left-click (Place)
        player.actionPlace = false; // Consume the action
      }
      if (player.actionRemove) {
        handleBlockInteraction(player, 2); // 2 for Right-click (Remove)
        player.actionRemove = false; // Consume the action
      }
    }

    function handleBlockInteraction(player, mouseButton) {
      if (gameMode === 'tag') return; // Double check

      raycaster.setFromCamera(pointer, player.camera); // Use shared 'pointer' {x:0, y:0} for center screen
      const intersects = raycaster.intersectObjects(worldObjects, false); // Check against world blocks

      if (intersects.length > 0) {
        const intersect = intersects[0];
        // Right-click or middle-click (button 2 or 1) to remove
        if (mouseButton === 2 || mouseButton === 1) {
          if (intersect.object.userData.blockType && intersect.object.userData.cannonBody) {
            removeBlockByMesh(intersect.object);
          }
        }
        // Left-click (button 0) to place
        else if (mouseButton === 0) {
          const placementPosition = new THREE.Vector3();
          // Calculate position *just* outside the clicked face
          placementPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, blockSize);

          // Check for collision with players before placing
          const newBlockHalfExtents = new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2);
          const newBlockAABB = new CANNON.AABB({
            lowerBound: new CANNON.Vec3(placementPosition.x - newBlockHalfExtents.x, placementPosition.y - newBlockHalfExtents.y, placementPosition.z - newBlockHalfExtents.z),
            upperBound: new CANNON.Vec3(placementPosition.x + newBlockHalfExtents.x, placementPosition.y + newBlockHalfExtents.y, placementPosition.z + newBlockHalfExtents.z)
          });

          let collisionWithPlayer = false;
          for (const p of players) {
            p.body.computeAABB(); // Ensure AABB is up-to-date
            if (newBlockAABB.overlaps(p.body.aabb)) {
              collisionWithPlayer = true;
              break;
            }
          }
          if (collisionWithPlayer) {
            // console.log("Cannot place block: intersects a player.");
            return; // Stop placement
          }

          // Check if a block already exists at the target position
          if (!worldObjects.some(obj => obj.position.distanceTo(placementPosition) < 0.1)) {
            const newBlockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const newBlockMaterial = blockMaterials[currentBlockType] || blockMaterials[blockTypes.STONE]; // Fallback
            addBlockInternal(placementPosition, currentBlockType, newBlockMaterial, newBlockGeometry);
          }
        }
      }
    }


    //----------------------------------------------------------------
    // ANIMATION LOOP
    //----------------------------------------------------------------
    const FWD = new THREE.Vector3(0, 0, -1);
    const RIGHT = new THREE.Vector3(1, 0, 0);
    const tempForwardVector = new THREE.Vector3();
    const tempLookAtTarget = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now();
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (world) world.step(timeStep, delta, 3); // Physics step

      // Update Tag Cooldown
      if (tagGameActive && tagCooldown > 0) {
        tagCooldown -= delta;
        if (tagCooldown < 0) tagCooldown = 0;
        // Update status display if cooldown is active (for the "IT" player)
        if (itPlayerId !== -1 && players[itPlayerId] && players[itPlayerId].isIt) {
          updatePlayerTagVisuals(players[itPlayerId]);
        }
      }

      const P1_controlsLocked = players.length > 0 && players[0].controls && players[0].controls.isLocked;

      players.forEach((player, index) => {
        const playerBody = player.body;
        const playerViewObject = player.yawObject;

        // --- NaN CHECK ---
        if (isNaN(playerBody.position.x) || isNaN(playerBody.position.y) || isNaN(playerBody.position.z)) {
          console.error(`Player ${player.id} body position is NaN! Respawning.`);
          enterLava(player); // Force a respawn via lava logic
          return; // Skip further processing for this player this frame
        }
        // --- END NaN CHECK ---

        // Player 2 keyboard look (only when P1 is locked/game active)
        if (index === 1 && P1_controlsLocked) {
          const lookSpeed = Math.PI * 0.5 * delta; // Adjust speed as needed
          if (player.lookLeft) player.targetYaw += lookSpeed;
          if (player.lookRight) player.targetYaw -= lookSpeed;
          if (player.lookUp) player.targetPitch += lookSpeed;
          if (player.lookDown) player.targetPitch -= lookSpeed;

          player.targetPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.targetPitch)); // Clamp pitch

          // Smooth interpolation for look
          player.currentYaw = THREE.MathUtils.lerp(player.currentYaw, player.targetYaw, 0.2);
          player.currentPitch = THREE.MathUtils.lerp(player.currentPitch, player.targetPitch, 0.2);

          playerViewObject.rotation.y = player.currentYaw;
          player.pitchObject.rotation.x = player.currentPitch;
        }

        // Movement logic (only when P1 is locked/game active)
        if (P1_controlsLocked) {
          let currentSpeed = playerSpeed;
          let targetVelocityY = playerBody.velocity.y; // Preserve existing Y velocity unless changed

          // Apply water physics or jump/descend logic
          if (player.isInWater) {
            currentSpeed *= waterProperties.speedFactor;
            if (player.moveUpAction) targetVelocityY = waterProperties.swimUpVelocity;
            else if (player.moveDownAction) targetVelocityY = waterProperties.swimDownVelocity;
          } else {
            if (player.moveUpAction && player.canJump) { targetVelocityY = jumpVelocity; player.canJump = false; }
            else if (player.moveDownAction) { targetVelocityY = -playerSpeed; player.canJump = false; } // Move down force
          }
          playerBody.velocity.y = targetVelocityY; // Apply Y velocity change

          // Calculate movement direction based on input and view
          const direction = new THREE.Vector3();
          direction.x = Number(player.moveRight) - Number(player.moveLeft);
          direction.z = Number(player.moveForward) - Number(player.moveBackward);

          playerBody.velocity.x = 0; // Reset horizontal velocity before applying new one
          playerBody.velocity.z = 0;

          if (direction.x !== 0 || direction.z !== 0) {
            // Get forward and right vectors relative to the player's view
            FWD.set(0, 0, -1).applyQuaternion(playerViewObject.quaternion);
            RIGHT.set(1, 0, 0).applyQuaternion(playerViewObject.quaternion);
            const moveDir = new THREE.Vector3(
              RIGHT.x * direction.x + FWD.x * direction.z, 0, // Ignore Y component for horizontal move
              RIGHT.z * direction.x + FWD.z * direction.z
            ).normalize();
            playerBody.velocity.x = moveDir.x * currentSpeed;
            playerBody.velocity.z = moveDir.z * currentSpeed;
          }

          // Handle P2's keyboard-based actions (place/remove)
          if (index === 1) {
            handlePlayerKeyboardActions(player);
          }
        } // End if(P1_controlsLocked)

        // Sync visual object to physics body
        playerViewObject.position.copy(playerBody.position);

        // Update direction indicator
        const indicator = player.directionIndicator;
        if (indicator) {
          indicator.position.copy(playerBody.position);
          indicator.position.y = playerBody.position.y - (playerHeight / 2) - 0.1; // Position below feet

          playerViewObject.getWorldDirection(tempForwardVector);
          tempForwardVector.y = 0; // Project onto horizontal plane
          tempForwardVector.normalize();
          if (tempForwardVector.lengthSq() > 0.001) { // Avoid issues if vector is zero
            tempLookAtTarget.copy(indicator.position).add(tempForwardVector);
            indicator.lookAt(tempLookAtTarget);
          }
        }

        // Check for falling out of the world
        if (playerBody.position.y < -30) {
          enterLava(player); // Use lava logic to respawn
        }
      }); // End forEach player

      // --- Render ---
      renderer.clear();
      players.forEach((player, i) => {
        if (!P1_controlsLocked && i > 0) { /* Skip P2 render if game not started/locked */ }
        else {
          const viewportWidth = window.innerWidth / NUM_PLAYERS;
          const viewportX = i * viewportWidth;
          renderer.setViewport(viewportX, 0, viewportWidth, window.innerHeight);
          renderer.setScissor(viewportX, 0, viewportWidth, window.innerHeight);
          if (player.camera) renderer.render(scene, player.camera); // Ensure camera exists
        }
      });
      // --- End Render ---

    } // End animate()


    //----------------------------------------------------------------
    // WORLD STATE MANAGEMENT (Clear, Save, Load)
    //----------------------------------------------------------------

    function clearWorld() {
      // Safely iterate and remove all blocks
      [...worldObjects].forEach(obj => removeBlockByMesh(obj));
      worldObjects = []; // Ensure array is empty

      // Reset player states related to the world
      players.forEach(player => {
        player.isInWater = false;
        player.waterContactCount = 0;
        player.canJump = false;
      });
      // Reset gravity if no one is in water
      if (!players.some(p => p.isInWater)) {
        world.gravity.set(0, originalGravityY, 0);
      }
      if (initialGroundMesh) initialGroundMesh.visible = true; // Show the base plane again
    }

    function getCurrentWorldData() {
      const blocksData = worldObjects.map(obj => ({
        x: obj.position.x, y: obj.position.y, z: obj.position.z,
        type: obj.userData.blockType
      }));

      const p1YawObject = players[0].yawObject;
      const playerData = {
        position: { x: players[0].body.position.x, y: players[0].body.position.y, z: players[0].body.position.z },
        quaternion: { x: p1YawObject.quaternion.x, y: p1YawObject.quaternion.y, z: p1YawObject.quaternion.z, w: p1YawObject.quaternion.w }
      };
      return { blocks: blocksData, player: playerData };
    }

    function addBlockFromData(blockData) {
      const { x, y, z, type } = blockData;
      const position = new THREE.Vector3(x, y, z);
      const material = blockMaterials[type] || blockMaterials[blockTypes.STONE];
      const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      addBlockInternal(position, type, material, geometry);
    }

    async function loadWorldFromSaveData(worldData) {
      clearWorld(); // Clear existing blocks and reset states

      worldData.blocks.forEach(blockData => addBlockFromData(blockData));

      resetPlayersToSpawn(); // Reset players to default spawn positions/states

      // Optionally restore P1 position if saved
      if (worldData.player && worldData.player.position) {
        const p1Data = worldData.player;
        players[0].body.position.set(p1Data.position.x, p1Data.position.y, p1Data.position.z);
        if (p1Data.quaternion) {
          players[0].yawObject.quaternion.set(p1Data.quaternion.x, p1Data.quaternion.y, p1Data.quaternion.z, p1Data.quaternion.w);
        }
        players[0].yawObject.position.copy(players[0].body.position); // Sync view object
      }

      if (initialGroundMesh) initialGroundMesh.visible = false; // Hide base plane if loading a world
      console.log("World loaded from data.");
    }

    //----------------------------------------------------------------
    // TAG GAME LOGIC
    //----------------------------------------------------------------

    function updateGameModeUI() {
      document.getElementById('creativeModeButton').classList.toggle('selected', gameMode === 'creative');
      document.getElementById('tagModeButton').classList.toggle('selected', gameMode === 'tag');
      document.getElementById('tagInstructions').style.display = gameMode === 'tag' ? 'block' : 'none';

      const P1_controlsLocked = players.length > 0 && players[0].controls && players[0].controls.isLocked;
      // Block selector only visible in creative AND when game is running
      document.getElementById('block-selector').style.display = (gameMode === 'creative' && P1_controlsLocked) ? 'flex' : 'none';
    }

    function startTagGame() {
      if (gameMode !== 'tag' || NUM_PLAYERS < 2) {
        tagGameActive = false;
        return;
      }
      console.log("Starting Tag Game...");
      tagGameActive = true;
      itPlayerId = Math.floor(Math.random() * NUM_PLAYERS);
      tagCooldown = TAG_COOLDOWN_DURATION / 2; // Start with a short grace period

      players.forEach((player, i) => {
        player.isIt = (i === itPlayerId);
        updatePlayerTagVisuals(player); // Update visuals for all players
      });
      console.log(`Tag game started. Player ${itPlayerId + 1} is IT.`);
    }

    function endTagGame() {
      if (!tagGameActive) return; // Don't do anything if not active
      console.log("Ending Tag Game...");
      tagGameActive = false;
      itPlayerId = -1;
      tagCooldown = 0;
      players.forEach(player => {
        player.isIt = false;
        updatePlayerTagVisuals(player); // Resets visuals and hides status for all
      });
      console.log("Tag game ended or paused.");
    }

    function resetTagGameElements() { // Called when switching to creative or full world reset/load
      endTagGame();
    }

    function updatePlayerTagVisuals(player, isResize = false) {
      if (!player) return; // Safety check

      if (player.directionIndicator) {

        // --- FORCED DEBUGGING SECTION (Uncomment to test basic visibility) ---
        /*
        console.log("DEBUG: Forcing indicator visuals for player", player.id)
        player.directionIndicator.material.color.setHex(0x00ff00); // Bright green
        player.directionIndicator.material.emissive.setHex(0x00ff00);
        player.directionIndicator.scale.set(2, 2, 2); // Make it big
        player.directionIndicator.visible = true; // Force visible
        return; // Skip rest of logic when debugging
        */
        // --- END FORCED DEBUGGING SECTION ---

        // --- Regular Logic (Comment out the debug section above to use this) ---
        if (tagGameActive && player.isIt) {
          player.directionIndicator.material.color.setHex(0xff0000); // Red for "It"
          player.directionIndicator.material.emissive.setHex(0xdd0000);
          player.directionIndicator.scale.set(1.5, 1.5, 1.5);
        } else if (tagGameActive && !player.isIt) {
          player.directionIndicator.material.color.setHex(0x00ff00); // Green for Runner
          player.directionIndicator.material.emissive.setHex(0x00dd00);
          player.directionIndicator.scale.set(1.2, 1.2, 1.2);
        } else { // Not tag game or creative mode
          player.directionIndicator.material.color.setHex(0xffA500); // Original color
          player.directionIndicator.material.emissive.setHex(0xcc8400);
          player.directionIndicator.scale.set(1, 1, 1);
        }
        // --- End Regular Logic ---
      }

      if (player.tagStatusElement) {
        const P1_controlsLocked = players.length > 0 && players[0].controls && players[0].controls.isLocked;
        if (tagGameActive && P1_controlsLocked) {
          player.tagStatusElement.textContent = player.isIt ? "YOU ARE IT!" : "RUN!";
          if (tagCooldown > 0 && player.isIt) { // Only show cooldown to the one who is IT
            player.tagStatusElement.textContent += ` (CD: ${tagCooldown.toFixed(1)}s)`;
          }
          player.tagStatusElement.style.display = 'block';
          // Position/size update, also on resize
          const viewportWidth = window.innerWidth / NUM_PLAYERS;
          const viewportX = player.id * viewportWidth;
          player.tagStatusElement.style.left = `${viewportX}px`;
          player.tagStatusElement.style.width = `${viewportWidth}px`;
        } else {
          player.tagStatusElement.textContent = '';
          player.tagStatusElement.style.display = 'none';
        }
      }
    }

    // forced = true means the switch happens without a physical tag (e.g., lava death)
    function switchItPlayer(oldItPlayerId, newItPlayerId, forced = false) {
      if (!tagGameActive && !forced) return; // Allow forced switch even if game not active momentarily
      if (oldItPlayerId === newItPlayerId) return; // Can't tag yourself

      if (players[oldItPlayerId]) players[oldItPlayerId].isIt = false;
      if (players[newItPlayerId]) players[newItPlayerId].isIt = true;
      itPlayerId = newItPlayerId;
      tagCooldown = TAG_COOLDOWN_DURATION; // Reset cooldown on any switch

      // Update visuals for both involved players
      if (players[oldItPlayerId]) updatePlayerTagVisuals(players[oldItPlayerId]);
      if (players[newItPlayerId]) updatePlayerTagVisuals(players[newItPlayerId]);

      console.log(`Tag! Player ${newItPlayerId + 1} is now IT. Cooldown: ${tagCooldown}s`);
    }
    //----------------------------------------------------------------
    // MAIN UI SETUP
    //----------------------------------------------------------------

    function setupUIAndEventListeners() {
      const blocker = document.getElementById('blocker');
      const instructionsDiv = document.getElementById('instructions');
      const playButton = document.getElementById('playButton');
      const saveLoadUIDiv = document.getElementById('save-load-ui');

      playButton.addEventListener('click', () => {
        if (players.length > 0 && players[0].controls) players[0].controls.lock();
      });

      // Ensure controls exist before adding listeners
      if (players.length > 0 && players[0].controls) {

        players[0].controls.addEventListener('lock', () => {
          console.log("Controls Locked");
          instructionsDiv.style.display = 'none';
          blocker.style.display = 'none';
          saveLoadUIDiv.style.display = 'none'; // Hide save/load when playing

          if (gameMode === 'tag') {
            startTagGame();
          } else {
            endTagGame(); // Ensure tag elements are off if starting in creative
          }
          updateGameModeUI(); // Controls block selector visibility based on mode + lock state

          players.forEach(p => {
            if (p.directionIndicator) p.directionIndicator.visible = true; // SHOW indicators
            if (p.crosshairElement) p.crosshairElement.style.display = 'block'; // SHOW crosshairs
            updatePlayerTagVisuals(p); // Update tag visuals (shows/hides status text, sets indicator colors)
          });
          updateCrosshairPositions(); // Set crosshair positions
        });

        players[0].controls.addEventListener('unlock', () => {
          console.log("Controls Unlocked");
          blocker.style.display = 'flex';
          instructionsDiv.style.display = '';
          saveLoadUIDiv.style.display = 'block'; // Always show save/load when unlocked

          endTagGame(); // ALWAYS end any active tag game when unlocking/pausing
          updateGameModeUI(); // Update UI state (will hide block selector as game is not locked)

          players.forEach(p => {
            if (p.directionIndicator) p.directionIndicator.visible = false; // HIDE indicators
            if (p.crosshairElement) p.crosshairElement.style.display = 'none'; // HIDE crosshairs
            // updatePlayerTagVisuals is called by endTagGame, ensuring status text is hidden etc
          });
          populateWorldList(); // Refresh world list
        });
      } // end if controls exist

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousedown', onMouseDown);

      // --- Game Mode Buttons ---
      const creativeModeButton = document.getElementById('creativeModeButton');
      const tagModeButton = document.getElementById('tagModeButton');
      creativeModeButton.addEventListener('click', () => {
        gameMode = 'creative';
        updateGameModeUI();
        resetTagGameElements(); // Clear any tag state immediately
      });
      tagModeButton.addEventListener('click', () => {
        if (NUM_PLAYERS < 2) {
          alert("Tag mode requires at least 2 players.");
          return;
        }
        gameMode = 'tag';
        updateGameModeUI();
      });
      // --- End Game Mode Buttons ---


      // --- Save/Load/New World Buttons ---
      const worldNameInput = document.getElementById('worldNameInput');
      const saveWorldButton = document.getElementById('saveWorldButton');
      const worldListSelect = document.getElementById('worldListSelect');
      const loadWorldButton = document.getElementById('loadWorldButton');
      const deleteWorldButton = document.getElementById('deleteWorldButton');
      const newWorldButton = document.getElementById('newWorldButton');

      saveWorldButton.addEventListener('click', async () => {
        const worldName = worldNameInput.value.trim();
        if (!worldName) { alert("Please enter a world name."); return; }
        try {
          const worldData = getCurrentWorldData();
          await saveWorldDB(worldName, worldData);
          alert(`World "${worldName}" saved!`);
          worldNameInput.value = ''; populateWorldList();
        } catch (error) { console.error("Error saving world:", error); alert(`Failed to save world: ${error.message || error}`); }
      });

      loadWorldButton.addEventListener('click', async () => {
        const worldName = worldListSelect.value;
        if (!worldName || worldListSelect.selectedOptions.length === 0 || worldListSelect.selectedOptions[0].disabled) {
          alert("Please select a valid world to load."); return;
        }
        if (!confirm(`Load world "${worldName}"? Current unsaved progress will be lost.`)) return;
        resetTagGameElements(); // Reset tag game state BEFORE loading
        try {
          const worldData = await loadWorldDB(worldName);
          if (worldData) {
            await loadWorldFromSaveData(worldData);
            alert(`World "${worldName}" loaded. Click "Click to play" to continue.`);
            if (initialGroundMesh) initialGroundMesh.visible = false; // Ensure base plane is hidden
          } else { alert(`World "${worldName}" not found or data is corrupt.`); }
        } catch (error) { console.error("Error loading world:", error); alert(`Failed to load world: ${error.message || error}`); }
      });

      deleteWorldButton.addEventListener('click', async () => {
        const worldName = worldListSelect.value;
        if (!worldName || worldListSelect.selectedOptions.length === 0 || worldListSelect.selectedOptions[0].disabled) {
          alert("Please select a valid world to delete."); return;
        }
        if (confirm(`Are you sure you want to delete world "${worldName}"? This cannot be undone.`)) {
          try {
            await deleteWorldDB(worldName);
            alert(`World "${worldName}" deleted.`); populateWorldList();
          } catch (error) { console.error("Error deleting world:", error); alert(`Failed to delete world: ${error.message || error}`); }
        }
      });

      newWorldButton.addEventListener('click', () => {
        if (!confirm("Create a new procedural world? Current unsaved progress will be lost.")) return;
        resetTagGameElements(); // Reset tag game state BEFORE new world
        clearWorld();
        if (initialGroundMesh) initialGroundMesh.visible = false; // Hide base plane
        resetPlayersToSpawn();
        generateWorld();
        alert("New procedural world created. Click 'Click to play' to continue.");
      });
      // --- End Save/Load/New World Buttons ---

    } // End setupUIAndEventListeners

    async function populateWorldList() {
      const worldListSelect = document.getElementById('worldListSelect');
      try {
        const names = await getAllWorldNamesDB();
        worldListSelect.innerHTML = ''; // Clear existing options
        if (names.length === 0) {
          const option = document.createElement('option');
          option.textContent = "No saved worlds"; option.disabled = true;
          worldListSelect.appendChild(option);
        } else {
          names.forEach(name => {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            worldListSelect.appendChild(option);
          });
        }
      } catch (error) {
        console.error("Error populating world list:", error);
        worldListSelect.innerHTML = `<option disabled>Error: ${error.message || error}</option>`;
      }
    }

  </script>
</body>

</html>