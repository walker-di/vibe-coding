<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniCraft.js - Split-Screen</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #instructions {
      width: 80%;
      max-width: 600px;
      /* Slightly wider for more instructions */
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: center;
      color: white;
      background-color: rgba(50, 50, 50, 0.8);
      border-radius: 10px;
      max-height: 90vh;
      overflow-y: auto;
    }

    #instructions p:first-of-type {
      cursor: pointer;
      font-weight: bold;
    }

    .crosshair {
      /* Changed to class for multiple crosshairs */
      position: absolute;
      width: 2px;
      height: 10px;
      background-color: white;
      transform: translate(-50%, -50%);
      pointer-events: none;
      mix-blend-mode: difference;
      display: none;
      /* Initially hidden, shown by JS */
    }

    .crosshair::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -4px;
      width: 10px;
      height: 2px;
      background-color: white;
      transform: translateY(-50%);
    }

    #crosshairP1 {
      /* ID for Player 1's crosshair */
      /* Positioned by JS based on viewport */
    }

    #crosshairP2 {
      /* ID for Player 2's crosshair */
      /* Positioned by JS based on viewport */
    }


    #block-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      gap: 10px;
      z-index: 10;
      /* Ensure it's above viewports */
    }

    .block-option {
      width: 40px;
      height: 40px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      user-select: none;
      font-size: 10px;
    }

    .block-option.selected {
      border-color: white;
      box-shadow: 0 0 10px cyan;
    }

    #save-load-ui {
      margin-top: 20px;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 8px;
      text-align: left;
    }

    #save-load-ui h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    #save-load-ui input[type="text"],
    #save-load-ui select {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #666;
      background-color: #444;
      color: white;
      margin-bottom: 10px;
      box-sizing: border-box;
    }

    #save-load-ui button {
      padding: 8px 12px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #save-load-ui button:hover {
      background-color: #777;
    }

    .save-load-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }

    .save-load-row input[type="text"] {
      flex-grow: 1;
    }

    .world-management-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .world-management-row select {
      flex-grow: 1;
      min-height: 100px;
    }

    .world-management-buttons {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .world-management-buttons button {
      width: 100%;
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <h1>MiniCraft.js - Split Screen</h1>
      <p id="playButton">Click to play</p>
      <p>
        <b>Player 1 (Left Screen):</b><br>
        WASD: Move<br>Space: Jump / Swim Up<br>Shift: Descend / Swim Down<br>Mouse: Look<br>Left Click: Place
        Block<br>Right Click: Remove Block<br>1-7: Select Block Type
      </p>
      <p>
        <b>Player 2 (Right Screen):</b><br>
        IJKL: Move<br>U: Jump / Swim Up<br>H: Descend / Swim Down<br>Arrow Keys: Look Around<br>O: Place Block<br>P:
        Remove Block<br>(Block type shared with Player 1)
      </p>

      <div id="save-load-ui" style="display: none;">
        <h3>Save Current World</h3>
        <div class="save-load-row">
          <input type="text" id="worldNameInput" placeholder="World Name">
          <button id="saveWorldButton">Save</button>
        </div>
        <hr style="margin: 15px 0; border-color: #666;">
        <h3>Manage Worlds</h3>
        <div class="world-management-row">
          <select id="worldListSelect" size="5"></select>
          <div class="world-management-buttons">
            <button id="loadWorldButton">Load</button>
            <button id="deleteWorldButton">Delete</button>
          </div>
        </div>
        <button id="newWorldButton" style="width: 100%;">Create New Procedural World</button>
      </div>
    </div>
  </div>
  <div id="crosshairP1" class="crosshair"></div>
  <div id="crosshairP2" class="crosshair"></div>
  <div id="block-selector"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, renderer, world;
    let worldObjects = [];

    const NUM_PLAYERS = 2;
    const players = []; // Array to hold player data

    const timeStep = 1 / 60;
    let playerMaterial, groundMaterial, playerGroundContactMaterial;

    const worldSize = { width: 20, depth: 20, height: 10 };
    const blockSize = 1;

    const playerHeight = 1.8;
    const playerRadius = 0.4;
    const playerSpeed = 5.0;
    const jumpVelocity = 7.0;
    const initialGravity = 20.0;

    const blockTypes = {
      GRASS: 'grass', DIRT: 'dirt', STONE: 'stone', WOOD: 'wood',
      WATER: 'water', LAVA: 'lava', GLOWSTONE: 'glowstone'
    };
    let currentBlockType = blockTypes.GRASS; // Shared block type for now
    const blockMaterials = {};

    let lastTime = performance.now();

    const originalGravityY = -initialGravity;
    const waterProperties = {
      gravityFactor: 0.3, speedFactor: 0.5, damping: 0.9,
      swimUpVelocity: 4.0, swimDownVelocity: -4.0
    };
    const originalPlayerDamping = 0.3;

    let db;
    const DB_NAME = 'MiniCraftWorldsDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'worlds';
    let initialGroundMesh, initialGroundBody;

    // Raycaster for block interaction - will be reused per player
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(); // For P1 mouse input


    function openDB() {
      return new Promise((resolve, reject) => {
        if (db) {
          resolve(db);
          return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (event) => reject("IndexedDB error: " + event.target.errorCode);
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };
        request.onupgradeneeded = (event) => {
          event.target.result.createObjectStore(STORE_NAME, { keyPath: 'name' });
        };
      });
    }
    async function saveWorldDB(worldName, worldData) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ name: worldName, data: worldData });
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject("Save error: " + event.target.error);
      });
    }
    async function loadWorldDB(worldName) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(worldName);
        request.onsuccess = (event) => resolve(event.target.result ? event.target.result.data : null);
        request.onerror = (event) => reject("Load error: " + event.target.error);
      });
    }
    async function getAllWorldNamesDB() {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAllKeys();
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject("Error fetching world names: " + event.target.error);
      });
    }
    async function deleteWorldDB(worldName) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(worldName);
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject("Delete error: " + event.target.error);
      });
    }

    init();

    function createTexture(color, text = null, isFluid = false) {
      const canvas = document.createElement('canvas');
      canvas.width = 64; canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.fillRect(0, 0, 64, 64);
      if (!isFluid) {
        context.strokeStyle = 'rgba(0,0,0,0.2)'; context.lineWidth = 2;
        context.strokeRect(1, 1, 62, 62);
      }
      if (text) {
        context.fillStyle = isFluid ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.5)';
        context.font = '10px Arial'; context.textAlign = 'center';
        context.textBaseline = 'middle'; context.fillText(text, 32, 32);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter;
      return texture;
    }
    function initMaterials() {
      const grassTopTexture = createTexture('#6A994E');
      const grassSideTexture = createTexture('#A7C957');
      const dirtTexture = createTexture('#8C6A48');
      const stoneTexture = createTexture('#808080');
      const woodTexture = createTexture('#A0522D');
      const waterTexture = createTexture('rgba(50, 100, 200, 0.6)', null, true);
      const lavaTexture = createTexture('#FF6000', null, true);
      const glowstoneTexture = createTexture('#FFEE88', 'GLOW');

      blockMaterials[blockTypes.GRASS] = [
        grassSideTexture, grassSideTexture, grassTopTexture, dirtTexture, grassSideTexture, grassSideTexture
      ].map(texture => new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 }));
      blockMaterials[blockTypes.DIRT] = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9, metalness: 0 });
      blockMaterials[blockTypes.STONE] = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.2 });
      blockMaterials[blockTypes.WOOD] = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
      blockMaterials[blockTypes.WATER] = new THREE.MeshStandardMaterial({
        map: waterTexture, transparent: true, opacity: 0.6, roughness: 0.2, metalness: 0.0, side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.LAVA] = new THREE.MeshStandardMaterial({
        map: lavaTexture, roughness: 0.8, metalness: 0.2,
        emissive: new THREE.Color(0xdd4400), emissiveIntensity: 0.8, side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.GLOWSTONE] = new THREE.MeshStandardMaterial({
        map: glowstoneTexture, roughness: 0.9, metalness: 0.1,
        emissive: new THREE.Color(0xffffaa), emissiveIntensity: 0.9
      });
    }

    function createPlayerDirectionIndicatorMesh() {
      const length = 0.5;
      const baseWidth = 0.3;
      const prismHeight = 0.1;

      const shape = new THREE.Shape();
      shape.moveTo(length, 0);
      shape.lineTo(0, baseWidth / 2);
      shape.lineTo(0, -baseWidth / 2);
      shape.closePath();

      const extrudeSettings = {
        depth: prismHeight,
        bevelEnabled: false
      };

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.rotateX(Math.PI / 2);
      geometry.rotateY(-Math.PI / 2);
      geometry.translate(0, prismHeight / 2, 0);

      const material = new THREE.MeshStandardMaterial({
        color: 0xffA500,
        emissive: 0xcc8400,
        roughness: 0.7,
        metalness: 0.2,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      return mesh;
    }

    async function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 10, 75);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setScissorTest(true);
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 80, 30);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 200;
      const shadowCamSize = 30;
      directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize;
      scene.add(directionalLight);


      initMaterials();
      await openDB();

      world = new CANNON.World();
      world.gravity.set(0, -initialGravity, 0);
      world.broadphase = new CANNON.NaiveBroadphase();

      playerMaterial = new CANNON.Material("playerMaterial");
      groundMaterial = new CANNON.Material("groundMaterial");
      playerGroundContactMaterial = new CANNON.ContactMaterial(playerMaterial, groundMaterial, { friction: 0.0, restitution: 0.0 });
      world.addContactMaterial(playerGroundContactMaterial);

      // Initialize players
      for (let i = 0; i < NUM_PLAYERS; i++) {
        const player = {
          id: i,
          camera: new THREE.PerspectiveCamera(75, (window.innerWidth / NUM_PLAYERS) / window.innerHeight, 0.1, 1000),
          body: null,
          controls: null,
          yawObject: null, // Will be set based on player type
          pitchObject: new THREE.Object3D(),
          directionIndicator: createPlayerDirectionIndicatorMesh(),
          crosshairElement: document.getElementById(i === 0 ? 'crosshairP1' : 'crosshairP2'),

          moveForward: false, moveBackward: false, moveLeft: false, moveRight: false,
          moveUpAction: false, moveDownAction: false,
          lookLeft: false, lookRight: false, lookUp: false, lookDown: false,
          actionPlace: false, actionRemove: false,

          canJump: false,
          isInWater: false,
          waterContactCount: 0,

          targetYaw: 0,
          targetPitch: 0,
          currentYaw: 0,
          currentPitch: 0,
        };

        player.camera.position.y = playerHeight * 0.4;
        player.pitchObject.add(player.camera); // Camera is child of pitch object

        if (i === 0) { // Player 1 uses PointerLockControls
          player.controls = new PointerLockControls(player.camera, document.body); // PointerLockControls now owns camera
          player.yawObject = player.controls.getObject(); // This IS the yawObject
        } else { // Player 2 uses keyboard look
          player.yawObject = new THREE.Object3D();
          player.yawObject.add(player.pitchObject); // Pitch is child of yaw for P2
        }

        scene.add(player.yawObject); // Add player's root view object (yawObject) to scene
        scene.add(player.directionIndicator);
        player.directionIndicator.visible = false;

        const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius));
        const initialPlayerPos = new THREE.Vector3(
          worldSize.width / 4 + (i * blockSize * 3) - (blockSize * 1.5 * (NUM_PLAYERS - 1) / 2),
          worldSize.height + 2,
          worldSize.depth / 4
        );
        player.body = new CANNON.Body({
          mass: 70, position: new CANNON.Vec3(initialPlayerPos.x, initialPlayerPos.y, initialPlayerPos.z),
          shape: playerShape, material: playerMaterial, fixedRotation: true, linearDamping: originalPlayerDamping
        });
        world.addBody(player.body);
        player.yawObject.position.copy(player.body.position); // Initial sync of yawObject position

        player.body.userData = { playerId: i };

        player.body.addEventListener("collide", (event) => {
          const contact = event.contact; const upAxis = new CANNON.Vec3(0, 1, 0);
          let contactNormal = new CANNON.Vec3();
          if (contact.bi.id === player.body.id) contact.ni.negate(contactNormal);
          else contactNormal.copy(contact.ni);

          if (contactNormal.dot(upAxis) > 0.5) {
            const otherBody = (contact.bi.id === player.body.id) ? contact.bj : contact.bi;
            if (otherBody.mass === 0 && otherBody.collisionResponse !== 0 && (!otherBody.userData || otherBody.userData.playerId === undefined)) {
              if (!player.isInWater) player.canJump = true;
            }
          }
        });
        player.body.addEventListener("beginContact", (event) => {
          const otherBody = event.bodyA.id === player.body.id ? event.bodyB : event.bodyA;
          if (otherBody.collisionResponse === 0 && otherBody.userData) {
            if (otherBody.userData.blockType === blockTypes.WATER) enterWater(player);
            else if (otherBody.userData.blockType === blockTypes.LAVA) enterLava(player);
          }
        });
        player.body.addEventListener("endContact", (event) => {
          const otherBody = event.bodyA.id === player.body.id ? event.bodyB : event.bodyA;
          if (otherBody.collisionResponse === 0 && otherBody.userData) {
            if (otherBody.userData.blockType === blockTypes.WATER) exitWater(player);
          }
        });

        players.push(player);
      }

      const groundGeo = new THREE.PlaneGeometry(worldSize.width * blockSize * 2, worldSize.depth * blockSize * 2);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x607D3B, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
      initialGroundMesh = new THREE.Mesh(groundGeo, groundMat);
      initialGroundMesh.rotation.x = -Math.PI / 2;
      initialGroundMesh.position.y = -blockSize / 2 + 0.01;
      initialGroundMesh.receiveShadow = true;
      scene.add(initialGroundMesh);

      const groundPlaneShape = new CANNON.Plane();
      initialGroundBody = new CANNON.Body({
        mass: 0, shape: groundPlaneShape, material: groundMaterial,
        position: new CANNON.Vec3(0, -blockSize / 2, 0)
      });
      initialGroundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      world.addBody(initialGroundBody);

      setupUIAndEventListeners();
      setupBlockSelector();

      clearWorld();
      if (initialGroundMesh) initialGroundMesh.visible = true;

      resetPlayersToSpawn();
      generateWorld();
      animate();
    }

    function resetPlayersToSpawn() {
      players.forEach((player, i) => {
        const spawnPos = new THREE.Vector3(
          worldSize.width / 4 + (i * blockSize * 4) - (blockSize * 2 * (NUM_PLAYERS - 1) / 2),
          worldSize.height + 2,
          worldSize.depth / 4
        );
        player.body.position.copy(spawnPos);
        player.body.velocity.set(0, 0, 0);
        player.body.angularVelocity.set(0, 0, 0);

        player.yawObject.position.copy(player.body.position);
        player.yawObject.quaternion.set(0, 0, 0, 1);
        player.pitchObject.quaternion.set(0, 0, 0, 1); // Reset pitch object's rotation
        player.currentYaw = 0;
        player.currentPitch = 0;
        player.targetYaw = 0;
        player.targetPitch = 0;

        // For P1, ensure PointerLockControls internal rotations are also reset if possible
        // This is often tricky as PointerLockControls manages its own state.
        // A simpler approach is to rely on the next mouse move to "snap" it.
        // Or, if controls.reset() or similar existed, call it.
        if (player.controls && typeof player.controls.reset === 'function') { // Hypothetical reset
          // player.controls.reset(); 
        } else if (player.id === 0 && player.controls) {
          // For PointerLockControls, the camera is part of its hierarchy.
          // We've reset player.yawObject.quaternion. Player 1's camera rotation
          // will be updated by PointerLockControls on the next mouse move or lock event.
        }


        player.isInWater = false;
        player.waterContactCount = 0;
        player.canJump = false;
        world.gravity.set(0, originalGravityY, 0);
        player.body.linearDamping = originalPlayerDamping;
      });
    }


    function enterWater(player) {
      player.waterContactCount++;
      if (!player.isInWater && player.waterContactCount > 0) {
        player.isInWater = true;
        world.gravity.set(0, originalGravityY * waterProperties.gravityFactor, 0);
        player.body.linearDamping = waterProperties.damping;
      }
    }
    function exitWater(player) {
      player.waterContactCount--;
      if (player.isInWater && player.waterContactCount <= 0) {
        player.isInWater = false; player.waterContactCount = 0;
        const anyPlayerInWater = players.some(p => p.isInWater);
        if (!anyPlayerInWater) {
          world.gravity.set(0, originalGravityY, 0);
        }
        player.body.linearDamping = originalPlayerDamping;
      }
    }
    function enterLava(player) {
      const spawnPos = new THREE.Vector3(
        worldSize.width / 4 + (player.id * blockSize * 4) - (blockSize * 2 * (NUM_PLAYERS - 1) / 2),
        worldSize.height + 10,
        worldSize.depth / 4
      );
      player.body.position.copy(spawnPos);
      player.body.velocity.set(0, 0, 0);
      if (player.isInWater) { exitWater(player); }
    }

    function generateWorld() {
      const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      for (let x = 0; x < worldSize.width; x++) {
        for (let z = 0; z < worldSize.depth; z++) {
          const groundLevel = Math.floor(worldSize.height / 3);
          const height = groundLevel + Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let material; let blockType;
            if (y === height - 1 && y >= groundLevel) { material = blockMaterials[blockTypes.GRASS]; blockType = blockTypes.GRASS; }
            else if (y < height - 1 && y >= groundLevel - 2) { material = blockMaterials[blockTypes.DIRT]; blockType = blockTypes.DIRT; }
            else { material = blockMaterials[blockTypes.STONE]; blockType = blockTypes.STONE; }

            const blockPos = new THREE.Vector3(
              x * blockSize - (worldSize.width * blockSize / 2) + blockSize / 2,
              y * blockSize + blockSize / 2,
              z * blockSize - (worldSize.depth * blockSize / 2) + blockSize / 2
            );
            addBlockInternal(blockPos, blockType, material, boxGeometry);
          }
        }
      }
    }

    function addBlockInternal(position, type, material, geometry) {
      const blockMesh = new THREE.Mesh(geometry, material);
      blockMesh.position.copy(position);
      blockMesh.castShadow = true;
      blockMesh.receiveShadow = true;
      blockMesh.userData.blockType = type;
      scene.add(blockMesh);
      worldObjects.push(blockMesh);

      const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2));
      const blockBody = new CANNON.Body({
        mass: 0, shape: blockShape,
        position: new CANNON.Vec3(blockMesh.position.x, blockMesh.position.y, blockMesh.position.z),
        material: groundMaterial
      });

      if (type === blockTypes.WATER || type === blockTypes.LAVA) {
        blockBody.collisionResponse = 0;
        blockBody.userData = { blockType: type };
      }
      if (type === blockTypes.GLOWSTONE || type === blockTypes.LAVA) {
        const light = new THREE.PointLight(0xffffff, 0, 8);
        light.position.copy(blockMesh.position);
        if (type === blockTypes.GLOWSTONE) { light.color.setHex(0xffffdd); light.intensity = 0.7; light.distance = 7; }
        else { light.color.setHex(0xff7700); light.intensity = 0.6; light.distance = 6; }
        scene.add(light);
        blockMesh.userData.light = light;
      }
      world.addBody(blockBody);
      blockMesh.userData.cannonBody = blockBody;
      return blockMesh;
    }


    function setupBlockSelector() {
      const selectorDiv = document.getElementById('block-selector');
      Object.keys(blockTypes).forEach((key) => {
        const type = blockTypes[key];
        const option = document.createElement('div');
        option.classList.add('block-option');
        option.textContent = key.substring(0, 4).toUpperCase();
        option.style.backgroundColor = getBlockColor(type);
        if (type === blockTypes.WATER || type === blockTypes.LAVA || type === blockTypes.GLOWSTONE) {
          option.style.color = (type === blockTypes.GLOWSTONE) ? 'black' : 'white';
        }
        option.title = key; option.dataset.blockType = type;
        if (type === currentBlockType) option.classList.add('selected');
        option.addEventListener('click', () => { currentBlockType = type; updateBlockSelectorUI(); });
        selectorDiv.appendChild(option);
      });
    }
    function getBlockColor(type) {
      switch (type) {
        case blockTypes.GRASS: return '#6A994E'; case blockTypes.DIRT: return '#8C6A48';
        case blockTypes.STONE: return '#808080'; case blockTypes.WOOD: return '#A0522D';
        case blockTypes.WATER: return 'rgba(50, 100, 200, 0.8)'; case blockTypes.LAVA: return '#FF6000';
        case blockTypes.GLOWSTONE: return '#FFEE88'; default: return '#FFFFFF';
      }
    }
    function updateBlockSelectorUI() {
      document.querySelectorAll('.block-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.blockType === currentBlockType);
      });
    }

    function onWindowResize() {
      players.forEach(player => {
        player.camera.aspect = (window.innerWidth / NUM_PLAYERS) / window.innerHeight;
        player.camera.updateProjectionMatrix();
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateCrosshairPositions();
    }

    function updateCrosshairPositions() {
      players.forEach((player, i) => {
        if (player.crosshairElement) {
          const viewportWidth = window.innerWidth / NUM_PLAYERS;
          const viewportX = i * viewportWidth;
          player.crosshairElement.style.left = `${viewportX + viewportWidth / 2}px`;
          player.crosshairElement.style.top = `${window.innerHeight / 2}px`;
        }
      });
    }


    function onKeyDown(event) {
      if (players[0].controls && !players[0].controls.isLocked && event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "SELECT") {
          return;
        }
      }

      switch (event.code) {
        case 'KeyW': players[0].moveForward = true; break;
        case 'KeyA': players[0].moveLeft = true; break;
        case 'KeyS': players[0].moveBackward = true; break;
        case 'KeyD': players[0].moveRight = true; break;
        case 'Space': players[0].moveUpAction = true; break;
        case 'ShiftLeft': players[0].moveDownAction = true; break;
        case 'Digit1': currentBlockType = blockTypes.GRASS; updateBlockSelectorUI(); break;
        case 'Digit2': currentBlockType = blockTypes.DIRT; updateBlockSelectorUI(); break;
        case 'Digit3': currentBlockType = blockTypes.STONE; updateBlockSelectorUI(); break;
        case 'Digit4': currentBlockType = blockTypes.WOOD; updateBlockSelectorUI(); break;
        case 'Digit5': currentBlockType = blockTypes.WATER; updateBlockSelectorUI(); break;
        case 'Digit6': currentBlockType = blockTypes.LAVA; updateBlockSelectorUI(); break;
        case 'Digit7': currentBlockType = blockTypes.GLOWSTONE; updateBlockSelectorUI(); break;
      }

      switch (event.code) {
        case 'KeyI': players[1].moveForward = true; break;
        case 'KeyJ': players[1].moveLeft = true; break;
        case 'KeyK': players[1].moveBackward = true; break;
        case 'KeyL': players[1].moveRight = true; break;
        case 'KeyU': players[1].moveUpAction = true; break;
        case 'KeyH': players[1].moveDownAction = true; break;
        case 'ArrowUp': players[1].lookUp = true; break;
        case 'ArrowDown': players[1].lookDown = true; break;
        case 'ArrowLeft': players[1].lookLeft = true; break;
        case 'ArrowRight': players[1].lookRight = true; break;
        case 'KeyO': players[1].actionPlace = true; break;
        case 'KeyP': players[1].actionRemove = true; break;
      }
    }
    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': players[0].moveForward = false; break;
        case 'KeyA': players[0].moveLeft = false; break;
        case 'KeyS': players[0].moveBackward = false; break;
        case 'KeyD': players[0].moveRight = false; break;
        case 'ShiftLeft': players[0].moveDownAction = false; break;
        case 'Space': players[0].moveUpAction = false; break;
      }
      switch (event.code) {
        case 'KeyI': players[1].moveForward = false; break;
        case 'KeyJ': players[1].moveLeft = false; break;
        case 'KeyK': players[1].moveBackward = false; break;
        case 'KeyL': players[1].moveRight = false; break;
        case 'KeyU': players[1].moveUpAction = false; break;
        case 'KeyH': players[1].moveDownAction = false; break;
        case 'ArrowUp': players[1].lookUp = false; break;
        case 'ArrowDown': players[1].lookDown = false; break;
        case 'ArrowLeft': players[1].lookLeft = false; break;
        case 'ArrowRight': players[1].lookRight = false; break;
        case 'KeyO': players[1].actionPlace = false; break;
        case 'KeyP': players[1].actionRemove = false; break;
      }
    }

    function onMouseDown(event) {
      const player = players[0];
      if (!player.controls || !player.controls.isLocked) return;

      handleBlockInteraction(player, event.button);
    }

    function handlePlayerKeyboardActions(player) {
      if (player.actionPlace) {
        handleBlockInteraction(player, 0);
        player.actionPlace = false;
      }
      if (player.actionRemove) {
        handleBlockInteraction(player, 2);
        player.actionRemove = false;
      }
    }

    function handleBlockInteraction(player, mouseButton) {
      raycaster.setFromCamera(pointer, player.camera);
      const intersects = raycaster.intersectObjects(worldObjects, false);

      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (mouseButton === 2 || mouseButton === 1) {
          if (intersect.object.userData.blockType && intersect.object.userData.cannonBody) {
            removeBlockByMesh(intersect.object);
          }
        } else if (mouseButton === 0) {
          const placementPosition = new THREE.Vector3();
          placementPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, blockSize);

          const newBlockHalfExtents = new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2);
          const newBlockAABB = new CANNON.AABB({
            lowerBound: new CANNON.Vec3(placementPosition.x - newBlockHalfExtents.x, placementPosition.y - newBlockHalfExtents.y, placementPosition.z - newBlockHalfExtents.z),
            upperBound: new CANNON.Vec3(placementPosition.x + newBlockHalfExtents.x, placementPosition.y + newBlockHalfExtents.y, placementPosition.z + newBlockHalfExtents.z)
          });

          let collisionWithPlayer = false;
          for (const p of players) {
            p.body.computeAABB();
            if (newBlockAABB.overlaps(p.body.aabb)) {
              collisionWithPlayer = true;
              break;
            }
          }
          if (collisionWithPlayer) {
            console.log("Cannot place block: intersects a player."); return;
          }

          if (!worldObjects.some(obj => obj.position.distanceTo(placementPosition) < 0.1)) {
            const newBlockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const newBlockMaterial = blockMaterials[currentBlockType] || blockMaterials[blockTypes.STONE];
            addBlockInternal(placementPosition, currentBlockType, newBlockMaterial, newBlockGeometry);
          }
        }
      }
    }


    function removeBlockByMesh(blockMesh) {
      if (blockMesh.userData.light) {
        scene.remove(blockMesh.userData.light);
        blockMesh.userData.light = null;
      }
      if (blockMesh.userData.cannonBody) {
        world.removeBody(blockMesh.userData.cannonBody);
      }
      scene.remove(blockMesh);
      const index = worldObjects.indexOf(blockMesh);
      if (index > -1) worldObjects.splice(index, 1);


      if (blockMesh.geometry) blockMesh.geometry.dispose();
      if (blockMesh.material) {
        const material = blockMesh.material;
        if (Array.isArray(material)) {
          material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
        } else { if (material.map) material.map.dispose(); material.dispose(); }
      }
    }


    const FWD = new THREE.Vector3(0, 0, -1);
    const RIGHT = new THREE.Vector3(1, 0, 0);
    const tempForwardVector = new THREE.Vector3();
    const tempLookAtTarget = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now(); const delta = (time - lastTime) / 1000; lastTime = time;

      if (world) world.step(timeStep, delta, 3);

      const P1_controlsLocked = players[0].controls && players[0].controls.isLocked;

      players.forEach((player, index) => {
        const playerBody = player.body;
        const playerViewObject = player.yawObject;

        if (index === 1 && P1_controlsLocked) {
          const lookSpeed = Math.PI * 0.5 * delta;
          if (player.lookLeft) player.targetYaw += lookSpeed;
          if (player.lookRight) player.targetYaw -= lookSpeed;
          if (player.lookUp) player.targetPitch += lookSpeed;
          if (player.lookDown) player.targetPitch -= lookSpeed;

          player.targetPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.targetPitch));

          player.currentYaw = THREE.MathUtils.lerp(player.currentYaw, player.targetYaw, 0.2);
          player.currentPitch = THREE.MathUtils.lerp(player.currentPitch, player.targetPitch, 0.2);

          playerViewObject.rotation.y = player.currentYaw;
          player.pitchObject.rotation.x = player.currentPitch;
        }


        if (P1_controlsLocked) {
          let currentSpeed = playerSpeed; let targetVelocityY = playerBody.velocity.y;

          if (player.isInWater) {
            currentSpeed *= waterProperties.speedFactor;
            if (player.moveUpAction) targetVelocityY = waterProperties.swimUpVelocity;
            else if (player.moveDownAction) targetVelocityY = waterProperties.swimDownVelocity;
          } else {
            if (player.moveUpAction && player.canJump) { targetVelocityY = jumpVelocity; player.canJump = false; }
            else if (player.moveDownAction) { targetVelocityY = -playerSpeed; player.canJump = false; }
          }
          playerBody.velocity.y = targetVelocityY;

          const direction = new THREE.Vector3();
          direction.x = Number(player.moveRight) - Number(player.moveLeft);
          direction.z = Number(player.moveForward) - Number(player.moveBackward);

          playerBody.velocity.x = 0; playerBody.velocity.z = 0;

          if (direction.x !== 0 || direction.z !== 0) {
            FWD.set(0, 0, -1).applyQuaternion(playerViewObject.quaternion);
            RIGHT.set(1, 0, 0).applyQuaternion(playerViewObject.quaternion);
            const moveDir = new THREE.Vector3(
              RIGHT.x * direction.x + FWD.x * direction.z, 0,
              RIGHT.z * direction.x + FWD.z * direction.z
            ).normalize();
            playerBody.velocity.x = moveDir.x * currentSpeed;
            playerBody.velocity.z = moveDir.z * currentSpeed;
          }

          if (index === 1) {
            handlePlayerKeyboardActions(player);
          }
        }

        playerViewObject.position.copy(playerBody.position);

        const indicator = player.directionIndicator;
        if (indicator) {
          indicator.position.copy(playerBody.position);
          indicator.position.y = playerBody.position.y - (playerHeight / 2);

          playerViewObject.getWorldDirection(tempForwardVector);
          tempForwardVector.y = 0; tempForwardVector.normalize();
          if (tempForwardVector.lengthSq() > 0.001) {
            tempLookAtTarget.copy(indicator.position).add(tempForwardVector);
            indicator.lookAt(tempLookAtTarget);
          }
        }

        if (playerBody.position.y < -30) {
          enterLava(player);
        }
      });

      renderer.clear();

      players.forEach((player, i) => {
        const P1_controlsLocked = players[0].controls && players[0].controls.isLocked;
        if (!P1_controlsLocked && i > 0) {
          // Skip P2 render if game not started
        } else {
          const viewportWidth = window.innerWidth / NUM_PLAYERS;
          const viewportX = i * viewportWidth;

          renderer.setViewport(viewportX, 0, viewportWidth, window.innerHeight);
          renderer.setScissor(viewportX, 0, viewportWidth, window.innerHeight);
          renderer.render(scene, player.camera);
        }
      });
    }

    function clearWorld() {
      [...worldObjects].forEach(obj => removeBlockByMesh(obj));
      worldObjects = [];

      players.forEach(player => {
        player.isInWater = false;
        player.waterContactCount = 0;
        player.canJump = false;
      });
      if (!players.some(p => p.isInWater)) {
        world.gravity.set(0, originalGravityY, 0);
      }
    }

    function getCurrentWorldData() {
      const blocksData = worldObjects.map(obj => ({
        x: obj.position.x, y: obj.position.y, z: obj.position.z,
        type: obj.userData.blockType
      }));

      const p1YawObject = players[0].yawObject;
      const playerData = {
        position: { x: players[0].body.position.x, y: players[0].body.position.y, z: players[0].body.position.z },
        quaternion: { x: p1YawObject.quaternion.x, y: p1YawObject.quaternion.y, z: p1YawObject.quaternion.z, w: p1YawObject.quaternion.w }
      };
      return { blocks: blocksData, player: playerData };
    }

    function addBlockFromData(blockData) {
      const { x, y, z, type } = blockData;
      const position = new THREE.Vector3(x, y, z);
      const material = blockMaterials[type] || blockMaterials[blockTypes.STONE];
      const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      addBlockInternal(position, type, material, geometry);
    }

    async function loadWorldFromSaveData(worldData) {
      clearWorld();

      worldData.blocks.forEach(blockData => addBlockFromData(blockData));

      resetPlayersToSpawn();

      if (worldData.player && worldData.player.position) {
        const p1Data = worldData.player;
        players[0].body.position.set(p1Data.position.x, p1Data.position.y, p1Data.position.z);
        if (p1Data.quaternion) {
          players[0].yawObject.quaternion.set(p1Data.quaternion.x, p1Data.quaternion.y, p1Data.quaternion.z, p1Data.quaternion.w);
        }
        players[0].yawObject.position.copy(players[0].body.position);
      }

      if (initialGroundMesh) initialGroundMesh.visible = false;
      console.log("World loaded from data. Players reset to spawn points (P1 may use saved pos).");
    }

    function setupUIAndEventListeners() {
      const blocker = document.getElementById('blocker');
      const instructionsDiv = document.getElementById('instructions');
      const playButton = document.getElementById('playButton');

      playButton.addEventListener('click', () => {
        if (players[0].controls) players[0].controls.lock();
      });

      const saveLoadUIDiv = document.getElementById('save-load-ui');

      if (players[0].controls) {
        players[0].controls.addEventListener('lock', () => {
          instructionsDiv.style.display = 'none';
          blocker.style.display = 'none';
          saveLoadUIDiv.style.display = 'none';
          players.forEach(p => {
            if (p.directionIndicator) p.directionIndicator.visible = true;
            if (p.crosshairElement) p.crosshairElement.style.display = 'block';
          });
          updateCrosshairPositions();
        });
        players[0].controls.addEventListener('unlock', () => {
          blocker.style.display = 'flex';
          instructionsDiv.style.display = '';
          saveLoadUIDiv.style.display = 'block';
          players.forEach(p => {
            if (p.directionIndicator) p.directionIndicator.visible = false;
            if (p.crosshairElement) p.crosshairElement.style.display = 'none';
          });
          populateWorldList();
        });
      }

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousedown', onMouseDown);

      const worldNameInput = document.getElementById('worldNameInput');
      const saveWorldButton = document.getElementById('saveWorldButton');
      const worldListSelect = document.getElementById('worldListSelect');
      const loadWorldButton = document.getElementById('loadWorldButton');
      const deleteWorldButton = document.getElementById('deleteWorldButton');
      const newWorldButton = document.getElementById('newWorldButton');

      saveWorldButton.addEventListener('click', async () => {
        const worldName = worldNameInput.value.trim();
        if (!worldName) { alert("Please enter a world name."); return; }
        try {
          const worldData = getCurrentWorldData();
          await saveWorldDB(worldName, worldData);
          alert(`World "${worldName}" saved!`);
          worldNameInput.value = ''; populateWorldList();
        } catch (error) { console.error("Error saving world:", error); alert(`Failed to save world: ${error.message || error}`); }
      });
      loadWorldButton.addEventListener('click', async () => {
        const worldName = worldListSelect.value;
        if (!worldName || worldListSelect.selectedOptions.length === 0 || worldListSelect.selectedOptions[0].disabled) {
          alert("Please select a valid world to load."); return;
        }
        if (!confirm(`Load world "${worldName}"? Current unsaved progress will be lost.`)) return;
        try {
          const worldData = await loadWorldDB(worldName);
          if (worldData) {
            await loadWorldFromSaveData(worldData);
            alert(`World "${worldName}" loaded. Click "Click to play" to continue.`);
          } else { alert(`World "${worldName}" not found or data is corrupt.`); }
        } catch (error) { console.error("Error loading world:", error); alert(`Failed to load world: ${error.message || error}`); }
      });
      deleteWorldButton.addEventListener('click', async () => {
        const worldName = worldListSelect.value;
        if (!worldName || worldListSelect.selectedOptions.length === 0 || worldListSelect.selectedOptions[0].disabled) {
          alert("Please select a valid world to delete."); return;
        }
        if (confirm(`Are you sure you want to delete world "${worldName}"? This cannot be undone.`)) {
          try {
            await deleteWorldDB(worldName);
            alert(`World "${worldName}" deleted.`); populateWorldList();
          } catch (error) { console.error("Error deleting world:", error); alert(`Failed to delete world: ${error.message || error}`); }
        }
      });
      newWorldButton.addEventListener('click', () => {
        if (!confirm("Create a new procedural world? Current unsaved progress will be lost.")) return;
        clearWorld();
        if (initialGroundMesh) initialGroundMesh.visible = true;
        resetPlayersToSpawn();
        generateWorld();
        alert("New procedural world created. Click 'Click to play' to continue.");
      });
    }

    async function populateWorldList() {
      const worldListSelect = document.getElementById('worldListSelect');
      try {
        const names = await getAllWorldNamesDB();
        worldListSelect.innerHTML = '';
        if (names.length === 0) {
          const option = document.createElement('option');
          option.textContent = "No saved worlds"; option.disabled = true;
          worldListSelect.appendChild(option);
        } else {
          names.forEach(name => {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            worldListSelect.appendChild(option);
          });
        }
      } catch (error) {
        console.error("Error populating world list:", error);
        worldListSelect.innerHTML = `<option disabled>Error: ${error.message || error}</option>`;
      }
    }

  </script>
</body>

</html>