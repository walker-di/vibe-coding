<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniCraft.js - World Saving/Loading (Fixed)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #instructions {
      width: 80%;
      max-width: 500px;
      /* Increased max-width for new UI */
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: center;
      color: white;
      background-color: rgba(50, 50, 50, 0.8);
      border-radius: 10px;
    }

    #instructions p:first-of-type {
      /* The "Click to play" */
      cursor: pointer;
      font-weight: bold;
    }


    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 10px;
      background-color: white;
      transform: translate(-50%, -50%);
      pointer-events: none;
      mix-blend-mode: difference;
    }

    #crosshair::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -4px;
      width: 10px;
      height: 2px;
      background-color: white;
      transform: translateY(-50%);
    }

    #block-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      gap: 10px;
    }

    .block-option {
      width: 40px;
      height: 40px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      user-select: none;
      font-size: 10px;
    }

    .block-option.selected {
      border-color: white;
      box-shadow: 0 0 10px cyan;
    }

    /* Styles for Save/Load UI */
    #save-load-ui {
      margin-top: 20px;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 8px;
      text-align: left;
      /* Override parent center align */
    }

    #save-load-ui h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    #save-load-ui input[type="text"],
    #save-load-ui select {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #666;
      background-color: #444;
      color: white;
      margin-bottom: 10px;
      box-sizing: border-box;
      /* Ensure padding doesn't increase width */
    }

    #save-load-ui button {
      padding: 8px 12px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #save-load-ui button:hover {
      background-color: #777;
    }

    .save-load-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }

    .save-load-row input[type="text"] {
      flex-grow: 1;
    }

    .world-management-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .world-management-row select {
      flex-grow: 1;
      min-height: 100px;
      /* Ensure select is reasonably sized */
    }

    .world-management-buttons {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .world-management-buttons button {
      width: 100%;
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <h1>MiniCraft.js</h1>
      <p id="playButton">Click to play</p>
      <p>WASD: Move<br>Space: Jump / Swim Up<br>Shift: Descend / Swim Down<br>Mouse: Look<br>Left Click: Place
        Block<br>Right
        Click: Remove Block<br>1-7: Select Block Type</p>

      <div id="save-load-ui" style="display: none;">
        <h3>Save Current World</h3>
        <div class="save-load-row">
          <input type="text" id="worldNameInput" placeholder="World Name">
          <button id="saveWorldButton">Save</button>
        </div>
        <hr style="margin: 15px 0; border-color: #666;">
        <h3>Manage Worlds</h3>
        <div class="world-management-row">
          <select id="worldListSelect" size="5"></select>
          <div class="world-management-buttons">
            <button id="loadWorldButton">Load</button>
            <button id="deleteWorldButton">Delete</button>
          </div>
        </div>
        <button id="newWorldButton" style="width: 100%;">Create New Procedural World</button>
      </div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="block-selector"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, camera, renderer, controls;
    let worldObjects = [];

    let world;
    let playerBody;
    const timeStep = 1 / 60;
    let playerMaterial, groundMaterial, playerGroundContactMaterial;

    const worldSize = { width: 20, depth: 20, height: 10 };
    const blockSize = 1;

    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let moveUpAction = false, moveDown = false;

    const playerHeight = 1.8;
    const playerRadius = 0.4;
    const playerSpeed = 5.0;
    const jumpVelocity = 7.0;
    const initialGravity = 20.0;
    let canJump = false;

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    const blockTypes = {
      GRASS: 'grass', DIRT: 'dirt', STONE: 'stone', WOOD: 'wood',
      WATER: 'water', LAVA: 'lava', GLOWSTONE: 'glowstone'
    };
    let currentBlockType = blockTypes.GRASS;
    const blockMaterials = {};

    let lastTime = performance.now();

    let isInWater = false;
    let waterContactCount = 0;
    const originalGravityY = -initialGravity;
    const waterProperties = {
      gravityFactor: 0.3, speedFactor: 0.5, damping: 0.9,
      swimUpVelocity: 4.0, swimDownVelocity: -4.0
    };
    const originalPlayerDamping = 0.3;

    let db;
    const DB_NAME = 'MiniCraftWorldsDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'worlds';
    let initialGroundMesh, initialGroundBody;

    function openDB() {
      return new Promise((resolve, reject) => {
        if (db) {
          resolve(db);
          return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (event) => reject("IndexedDB error: " + event.target.errorCode);
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };
        request.onupgradeneeded = (event) => {
          event.target.result.createObjectStore(STORE_NAME, { keyPath: 'name' });
        };
      });
    }

    async function saveWorldDB(worldName, worldData) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ name: worldName, data: worldData });
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject("Save error: " + event.target.error);
      });
    }

    async function loadWorldDB(worldName) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(worldName);
        request.onsuccess = (event) => resolve(event.target.result ? event.target.result.data : null);
        request.onerror = (event) => reject("Load error: " + event.target.error);
      });
    }

    async function getAllWorldNamesDB() {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAllKeys();
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject("Error fetching world names: " + event.target.error);
      });
    }

    async function deleteWorldDB(worldName) {
      const currentDb = await openDB();
      return new Promise((resolve, reject) => {
        const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(worldName);
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject("Delete error: " + event.target.error);
      });
    }

    init(); // Call init to start the process

    function createTexture(color, text = null, isFluid = false) {
      const canvas = document.createElement('canvas');
      canvas.width = 64; canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.fillRect(0, 0, 64, 64);
      if (!isFluid) {
        context.strokeStyle = 'rgba(0,0,0,0.2)'; context.lineWidth = 2;
        context.strokeRect(1, 1, 62, 62);
      }
      if (text) {
        context.fillStyle = isFluid ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.5)';
        context.font = '10px Arial'; context.textAlign = 'center';
        context.textBaseline = 'middle'; context.fillText(text, 32, 32);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    function initMaterials() {
      const grassTopTexture = createTexture('#6A994E');
      const grassSideTexture = createTexture('#A7C957');
      const dirtTexture = createTexture('#8C6A48');
      const stoneTexture = createTexture('#808080');
      const woodTexture = createTexture('#A0522D');
      const waterTexture = createTexture('rgba(50, 100, 200, 0.6)', null, true);
      const lavaTexture = createTexture('#FF6000', null, true);
      const glowstoneTexture = createTexture('#FFEE88', 'GLOW');

      blockMaterials[blockTypes.GRASS] = [
        grassSideTexture, grassSideTexture, grassTopTexture, dirtTexture, grassSideTexture, grassSideTexture
      ].map(texture => new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 }));
      blockMaterials[blockTypes.DIRT] = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9, metalness: 0 });
      blockMaterials[blockTypes.STONE] = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.2 });
      blockMaterials[blockTypes.WOOD] = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
      blockMaterials[blockTypes.WATER] = new THREE.MeshStandardMaterial({
        map: waterTexture, transparent: true, opacity: 0.6, roughness: 0.2, metalness: 0.0, side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.LAVA] = new THREE.MeshStandardMaterial({
        map: lavaTexture, roughness: 0.8, metalness: 0.2,
        emissive: new THREE.Color(0xdd4400), emissiveIntensity: 0.8, side: THREE.DoubleSide
      });
      blockMaterials[blockTypes.GLOWSTONE] = new THREE.MeshStandardMaterial({
        map: glowstoneTexture, roughness: 0.9, metalness: 0.1,
        emissive: new THREE.Color(0xffffaa), emissiveIntensity: 0.9
      });
    }

    async function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 10, 75);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 80, 30);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 200;
      const shadowCamSize = 30;
      directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize;
      scene.add(directionalLight);

      initMaterials();
      await openDB();

      world = new CANNON.World();
      world.gravity.set(0, -initialGravity, 0);
      world.broadphase = new CANNON.NaiveBroadphase();

      playerMaterial = new CANNON.Material("playerMaterial");
      groundMaterial = new CANNON.Material("groundMaterial");
      playerGroundContactMaterial = new CANNON.ContactMaterial(playerMaterial, groundMaterial, { friction: 0.0, restitution: 0.0 });
      world.addContactMaterial(playerGroundContactMaterial);

      const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius));
      const initialPlayerPos = new THREE.Vector3(worldSize.width / 4, worldSize.height + 2, worldSize.depth / 4);
      playerBody = new CANNON.Body({
        mass: 70, position: new CANNON.Vec3(initialPlayerPos.x, initialPlayerPos.y, initialPlayerPos.z),
        shape: playerShape, material: playerMaterial, fixedRotation: true, linearDamping: originalPlayerDamping
      });
      world.addBody(playerBody);

      playerBody.addEventListener("collide", function (event) {
        const contact = event.contact; const upAxis = new CANNON.Vec3(0, 1, 0);
        let contactNormal = new CANNON.Vec3();
        if (contact.bi.id === playerBody.id) contact.ni.negate(contactNormal);
        else contactNormal.copy(contact.ni);
        if (contactNormal.dot(upAxis) > 0.5) {
          const otherBody = (contact.bi.id === playerBody.id) ? contact.bj : contact.bi;
          if (otherBody.mass === 0 && otherBody.collisionResponse !== 0) {
            if (!isInWater) canJump = true;
          }
        }
      });
      playerBody.addEventListener("beginContact", function (event) {
        const otherBody = event.bodyA.id === playerBody.id ? event.bodyB : event.bodyA;
        if (otherBody.collisionResponse === 0 && otherBody.userData) {
          if (otherBody.userData.blockType === blockTypes.WATER) enterWater();
          else if (otherBody.userData.blockType === blockTypes.LAVA) enterLava();
        }
      });
      playerBody.addEventListener("endContact", function (event) {
        const otherBody = event.bodyA.id === playerBody.id ? event.bodyB : event.bodyA;
        if (otherBody.collisionResponse === 0 && otherBody.userData) {
          if (otherBody.userData.blockType === blockTypes.WATER) exitWater();
        }
      });

      const groundGeo = new THREE.PlaneGeometry(worldSize.width * blockSize * 2, worldSize.depth * blockSize * 2);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x607D3B, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
      initialGroundMesh = new THREE.Mesh(groundGeo, groundMat);
      initialGroundMesh.rotation.x = -Math.PI / 2;
      initialGroundMesh.position.y = -blockSize / 2 + 0.01;
      initialGroundMesh.receiveShadow = true;
      scene.add(initialGroundMesh);

      const groundPlaneShape = new CANNON.Plane();
      initialGroundBody = new CANNON.Body({
        mass: 0, shape: groundPlaneShape, material: groundMaterial,
        position: new CANNON.Vec3(0, -blockSize / 2, 0)
      });
      initialGroundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      world.addBody(initialGroundBody);

      controls = new PointerLockControls(camera, document.body);
      camera.position.set(0, 0.7, 0);
      const playerCamObject = controls.getObject();
      playerCamObject.position.copy(playerBody.position);
      scene.add(playerCamObject);

      setupUIAndEventListeners();
      setupBlockSelector();

      // Create an initial procedural world on startup
      clearWorld();
      if (initialGroundMesh) initialGroundMesh.visible = true;

      playerBody.position.set(worldSize.width / 4, worldSize.height + 2, worldSize.depth / 4);
      playerBody.velocity.set(0, 0, 0); playerBody.angularVelocity.set(0, 0, 0);

      playerCamObject.quaternion.set(0, 0, 0, 1);
      playerCamObject.position.copy(playerBody.position);

      generateWorld();

      animate(); // Start animation loop AFTER all setup
    }

    function enterWater() {
      waterContactCount++;
      if (!isInWater && waterContactCount > 0) {
        isInWater = true;
        world.gravity.set(0, originalGravityY * waterProperties.gravityFactor, 0);
        playerBody.linearDamping = waterProperties.damping;
      }
    }
    function exitWater() {
      waterContactCount--;
      if (isInWater && waterContactCount <= 0) {
        isInWater = false; waterContactCount = 0;
        world.gravity.set(0, originalGravityY, 0);
        playerBody.linearDamping = originalPlayerDamping;
      }
    }
    function enterLava() {
      playerBody.position.set(worldSize.width / 4, worldSize.height + 10, worldSize.depth / 4);
      playerBody.velocity.set(0, 0, 0);
      if (isInWater) { waterContactCount = 0; exitWater(); }
    }

    function generateWorld() {
      const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize); // Can be shared
      for (let x = 0; x < worldSize.width; x++) {
        for (let z = 0; z < worldSize.depth; z++) {
          const groundLevel = Math.floor(worldSize.height / 3);
          const height = groundLevel + Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let material; let blockType;
            if (y === height - 1 && y >= groundLevel) { material = blockMaterials[blockTypes.GRASS]; blockType = blockTypes.GRASS; }
            else if (y < height - 1 && y >= groundLevel - 2) { material = blockMaterials[blockTypes.DIRT]; blockType = blockTypes.DIRT; }
            else { material = blockMaterials[blockTypes.STONE]; blockType = blockTypes.STONE; }

            const blockPos = new THREE.Vector3(
              x * blockSize - (worldSize.width * blockSize / 2) + blockSize / 2,
              y * blockSize + blockSize / 2,
              z * blockSize - (worldSize.depth * blockSize / 2) + blockSize / 2
            );
            addBlockInternal(blockPos, blockType, material, boxGeometry);
          }
        }
      }
    }

    function addBlockInternal(position, type, material, geometry) {
      const blockMesh = new THREE.Mesh(geometry, material);
      blockMesh.position.copy(position);
      blockMesh.castShadow = true;
      blockMesh.receiveShadow = true;
      blockMesh.userData.blockType = type;
      scene.add(blockMesh);
      worldObjects.push(blockMesh);

      const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2));
      const blockBody = new CANNON.Body({
        mass: 0, shape: blockShape,
        position: new CANNON.Vec3(blockMesh.position.x, blockMesh.position.y, blockMesh.position.z),
        material: groundMaterial
      });

      if (type === blockTypes.WATER || type === blockTypes.LAVA) {
        blockBody.collisionResponse = 0;
        blockBody.userData = { blockType: type };
      }
      if (type === blockTypes.GLOWSTONE || type === blockTypes.LAVA) {
        const light = new THREE.PointLight(0xffffff, 0, 8);
        light.position.copy(blockMesh.position);
        if (type === blockTypes.GLOWSTONE) { light.color.setHex(0xffffdd); light.intensity = 0.7; light.distance = 7; }
        else { light.color.setHex(0xff7700); light.intensity = 0.6; light.distance = 6; }
        scene.add(light);
        blockMesh.userData.light = light;
      }
      world.addBody(blockBody);
      blockMesh.userData.cannonBody = blockBody;
      return blockMesh;
    }


    function setupBlockSelector() {
      const selectorDiv = document.getElementById('block-selector');
      Object.keys(blockTypes).forEach((key) => {
        const type = blockTypes[key];
        const option = document.createElement('div');
        option.classList.add('block-option');
        option.textContent = key.substring(0, 4).toUpperCase();
        option.style.backgroundColor = getBlockColor(type);
        if (type === blockTypes.WATER || type === blockTypes.LAVA || type === blockTypes.GLOWSTONE) {
          option.style.color = (type === blockTypes.GLOWSTONE) ? 'black' : 'white';
        }
        option.title = key; option.dataset.blockType = type;
        if (type === currentBlockType) option.classList.add('selected');
        option.addEventListener('click', () => { currentBlockType = type; updateBlockSelectorUI(); });
        selectorDiv.appendChild(option);
      });
    }
    function getBlockColor(type) {
      switch (type) {
        case blockTypes.GRASS: return '#6A994E'; case blockTypes.DIRT: return '#8C6A48';
        case blockTypes.STONE: return '#808080'; case blockTypes.WOOD: return '#A0522D';
        case blockTypes.WATER: return 'rgba(50, 100, 200, 0.8)'; case blockTypes.LAVA: return '#FF6000';
        case blockTypes.GLOWSTONE: return '#FFEE88'; default: return '#FFFFFF';
      }
    }
    function updateBlockSelectorUI() {
      document.querySelectorAll('.block-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.blockType === currentBlockType);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onKeyDown(event) {
      if (controls && !controls.isLocked && event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
        // Allow typing in input fields when controls are not locked
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "SELECT") {
          return; // Don't process game keybinds
        }
      }
      switch (event.code) {
        case 'KeyW': moveForward = true; break; case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break; case 'KeyD': moveRight = true; break;
        case 'Space': moveUpAction = true; break; case 'ShiftLeft': moveDown = true; break;
        case 'Digit1': currentBlockType = blockTypes.GRASS; updateBlockSelectorUI(); break;
        case 'Digit2': currentBlockType = blockTypes.DIRT; updateBlockSelectorUI(); break;
        case 'Digit3': currentBlockType = blockTypes.STONE; updateBlockSelectorUI(); break;
        case 'Digit4': currentBlockType = blockTypes.WOOD; updateBlockSelectorUI(); break;
        case 'Digit5': currentBlockType = blockTypes.WATER; updateBlockSelectorUI(); break;
        case 'Digit6': currentBlockType = blockTypes.LAVA; updateBlockSelectorUI(); break;
        case 'Digit7': currentBlockType = blockTypes.GLOWSTONE; updateBlockSelectorUI(); break;
      }
    }
    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': moveForward = false; break; case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break; case 'KeyD': moveRight = false; break;
        case 'ShiftLeft': moveDown = false; break; case 'Space': moveUpAction = false; break;
      }
    }
    function onMouseDown(event) {
      if (!controls || !controls.isLocked) return; // Check if controls is defined
      pointer.set(0, 0); raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(worldObjects, false);

      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (event.button === 2 || event.ctrlKey) {
          if (intersect.object.userData.blockType && intersect.object.userData.cannonBody) {
            removeBlockByMesh(intersect.object);
          }
        } else if (event.button === 0) {
          const placementPosition = new THREE.Vector3();
          placementPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, blockSize);

          const newBlockHalfExtents = new CANNON.Vec3(blockSize / 2, blockSize / 2, blockSize / 2);
          const newBlockAABB = new CANNON.AABB({
            lowerBound: new CANNON.Vec3(placementPosition.x - newBlockHalfExtents.x, placementPosition.y - newBlockHalfExtents.y, placementPosition.z - newBlockHalfExtents.z),
            upperBound: new CANNON.Vec3(placementPosition.x + newBlockHalfExtents.x, placementPosition.y + newBlockHalfExtents.y, placementPosition.z + newBlockHalfExtents.z)
          });
          playerBody.computeAABB();
          if (newBlockAABB.overlaps(playerBody.aabb)) {
            console.log("Cannot place block: intersects player."); return;
          }
          if (!worldObjects.some(obj => obj.position.distanceTo(placementPosition) < 0.1)) {
            const newBlockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const newBlockMaterial = blockMaterials[currentBlockType] || blockMaterials[blockTypes.STONE];
            addBlockInternal(placementPosition, currentBlockType, newBlockMaterial, newBlockGeometry);
          }
        }
      }
    }

    function removeBlockByMesh(blockMesh) {
      if (blockMesh.userData.light) {
        scene.remove(blockMesh.userData.light);
        blockMesh.userData.light = null;
      }
      if (blockMesh.userData.cannonBody) {
        world.removeBody(blockMesh.userData.cannonBody);
      }
      scene.remove(blockMesh);
      const index = worldObjects.indexOf(blockMesh);
      if (index > -1) worldObjects.splice(index, 1);


      if (blockMesh.geometry) blockMesh.geometry.dispose();
      if (blockMesh.material) {
        const material = blockMesh.material;
        if (Array.isArray(material)) {
          material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
        } else { if (material.map) material.map.dispose(); material.dispose(); }
      }
    }


    const direction = new THREE.Vector3(); const FWD = new THREE.Vector3(0, 0, -1); const RIGHT = new THREE.Vector3(1, 0, 0);
    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now(); const delta = (time - lastTime) / 1000; lastTime = time;

      if (world) world.step(timeStep, delta, 3);

      if (controls && controls.isLocked) { // Check if controls is defined
        const playerObject = controls.getObject();
        let currentSpeed = playerSpeed; let targetVelocityY = playerBody.velocity.y;

        if (isInWater) {
          currentSpeed *= waterProperties.speedFactor;
          if (moveUpAction) targetVelocityY = waterProperties.swimUpVelocity;
          else if (moveDown) targetVelocityY = waterProperties.swimDownVelocity;
        } else {
          if (moveUpAction && canJump) { targetVelocityY = jumpVelocity; canJump = false; }
          else if (moveDown) { targetVelocityY = -playerSpeed; canJump = false; }
        }
        playerBody.velocity.y = targetVelocityY;

        direction.x = Number(moveRight) - Number(moveLeft);
        direction.z = Number(moveForward) - Number(moveBackward);
        playerBody.velocity.x = 0; playerBody.velocity.z = 0;

        if (direction.x !== 0 || direction.z !== 0) {
          FWD.set(0, 0, -1).applyQuaternion(playerObject.quaternion);
          RIGHT.set(1, 0, 0).applyQuaternion(playerObject.quaternion);
          const moveDir = new THREE.Vector3(
            RIGHT.x * direction.x + FWD.x * direction.z, 0,
            RIGHT.z * direction.x + FWD.z * direction.z
          ).normalize();
          playerBody.velocity.x = moveDir.x * currentSpeed;
          playerBody.velocity.z = moveDir.z * currentSpeed;
        }
        playerObject.position.copy(playerBody.position);

        if (playerBody.position.y < -30) {
          playerBody.position.set(worldSize.width / 4, worldSize.height + 10, worldSize.depth / 4);
          playerBody.velocity.set(0, 0, 0); canJump = false;
          if (isInWater) { waterContactCount = 0; exitWater(); }
        }
      }
      renderer.render(scene, camera);
    }

    function clearWorld() {
      [...worldObjects].forEach(obj => removeBlockByMesh(obj));
      worldObjects = []; // Ensure it's reset

      if (isInWater) { waterContactCount = 0; exitWater(); }
      canJump = false;
    }

    function getCurrentWorldData() {
      const blocksData = worldObjects.map(obj => ({
        x: obj.position.x, y: obj.position.y, z: obj.position.z,
        type: obj.userData.blockType
      }));
      const playerObject = controls.getObject();
      const playerData = {
        position: { x: playerBody.position.x, y: playerBody.position.y, z: playerBody.position.z },
        quaternion: { x: playerObject.quaternion.x, y: playerObject.quaternion.y, z: playerObject.quaternion.z, w: playerObject.quaternion.w }
      };
      return { blocks: blocksData, player: playerData };
    }

    function addBlockFromData(blockData) {
      const { x, y, z, type } = blockData;
      const position = new THREE.Vector3(x, y, z);
      const material = blockMaterials[type] || blockMaterials[blockTypes.STONE];
      const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      addBlockInternal(position, type, material, geometry);
    }

    async function loadWorldFromSaveData(worldData) {
      clearWorld();

      const playerPos = worldData.player.position;
      playerBody.position.set(playerPos.x, playerPos.y, playerPos.z);
      playerBody.velocity.set(0, 0, 0); playerBody.angularVelocity.set(0, 0, 0);

      const playerCamObject = controls.getObject();
      if (worldData.player.quaternion) {
        playerCamObject.quaternion.set(
          worldData.player.quaternion.x, worldData.player.quaternion.y,
          worldData.player.quaternion.z, worldData.player.quaternion.w
        );
      } else { playerCamObject.quaternion.set(0, 0, 0, 1); } // Reset if no quaternion
      playerCamObject.position.copy(playerBody.position);

      worldData.blocks.forEach(blockData => addBlockFromData(blockData));

      canJump = false; isInWater = false; waterContactCount = 0;
      world.gravity.set(0, originalGravityY, 0);
      playerBody.linearDamping = originalPlayerDamping;

      if (initialGroundMesh) initialGroundMesh.visible = false;

      console.log("World loaded from data.");
    }

    function setupUIAndEventListeners() {
      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');
      const playButton = document.getElementById('playButton');

      playButton.addEventListener('click', () => {
        if (controls) controls.lock(); // Check if controls is defined
      });

      if (controls) { // Ensure controls exists before adding listeners
        controls.addEventListener('lock', () => {
          instructions.style.display = 'none';
          blocker.style.display = 'none';
          saveLoadUIDiv.style.display = 'none';
        });
        controls.addEventListener('unlock', () => {
          blocker.style.display = 'flex';
          instructions.style.display = '';
          saveLoadUIDiv.style.display = 'block';
          populateWorldList();
        });
      }


      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousedown', onMouseDown);

      const saveLoadUIDiv = document.getElementById('save-load-ui');
      const worldNameInput = document.getElementById('worldNameInput');
      const saveWorldButton = document.getElementById('saveWorldButton');
      const worldListSelect = document.getElementById('worldListSelect');
      const loadWorldButton = document.getElementById('loadWorldButton');
      const deleteWorldButton = document.getElementById('deleteWorldButton');
      const newWorldButton = document.getElementById('newWorldButton');

      saveWorldButton.addEventListener('click', async () => {
        const worldName = worldNameInput.value.trim();
        if (!worldName) { alert("Please enter a world name."); return; }
        try {
          const worldData = getCurrentWorldData();
          await saveWorldDB(worldName, worldData);
          alert(`World "${worldName}" saved!`);
          worldNameInput.value = ''; populateWorldList();
        } catch (error) { console.error("Error saving world:", error); alert(`Failed to save world: ${error.message || error}`); }
      });

      loadWorldButton.addEventListener('click', async () => {
        const worldName = worldListSelect.value;
        if (!worldName || worldListSelect.selectedOptions.length === 0 || worldListSelect.selectedOptions[0].disabled) {
          alert("Please select a valid world to load."); return;
        }
        if (!confirm(`Load world "${worldName}"? Current unsaved progress will be lost.`)) return;
        try {
          const worldData = await loadWorldDB(worldName);
          if (worldData) {
            await loadWorldFromSaveData(worldData);
            alert(`World "${worldName}" loaded. Click "Click to play" to continue.`);
          } else { alert(`World "${worldName}" not found or data is corrupt.`); }
        } catch (error) { console.error("Error loading world:", error); alert(`Failed to load world: ${error.message || error}`); }
      });

      deleteWorldButton.addEventListener('click', async () => {
        const worldName = worldListSelect.value;
        if (!worldName || worldListSelect.selectedOptions.length === 0 || worldListSelect.selectedOptions[0].disabled) {
          alert("Please select a valid world to delete."); return;
        }
        if (confirm(`Are you sure you want to delete world "${worldName}"? This cannot be undone.`)) {
          try {
            await deleteWorldDB(worldName);
            alert(`World "${worldName}" deleted.`); populateWorldList();
          } catch (error) { console.error("Error deleting world:", error); alert(`Failed to delete world: ${error.message || error}`); }
        }
      });

      newWorldButton.addEventListener('click', () => {
        if (!confirm("Create a new procedural world? Current unsaved progress will be lost.")) return;
        clearWorld();
        if (initialGroundMesh) initialGroundMesh.visible = true;

        playerBody.position.set(worldSize.width / 4, worldSize.height + 2, worldSize.depth / 4);
        playerBody.velocity.set(0, 0, 0); playerBody.angularVelocity.set(0, 0, 0);
        const camObj = controls.getObject();
        camObj.quaternion.set(0, 0, 0, 1);
        camObj.position.copy(playerBody.position);

        generateWorld();
        alert("New procedural world created. Click 'Click to play' to continue.");
      });
    }

    async function populateWorldList() {
      const worldListSelect = document.getElementById('worldListSelect');
      try {
        const names = await getAllWorldNamesDB();
        worldListSelect.innerHTML = '';
        if (names.length === 0) {
          const option = document.createElement('option');
          option.textContent = "No saved worlds"; option.disabled = true;
          worldListSelect.appendChild(option);
        } else {
          names.forEach(name => {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            worldListSelect.appendChild(option);
          });
        }
      } catch (error) {
        console.error("Error populating world list:", error);
        worldListSelect.innerHTML = `<option disabled>Error: ${error.message || error}</option>`;
      }
    }

  </script>
</body>

</html>