<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MiniCraft.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }

    canvas {
      display: block;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #instructions {
      width: 50%;
      max-width: 400px;
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      text-align: center;
      color: white;
      background-color: rgba(50, 50, 50, 0.8);
      border-radius: 10px;
      cursor: pointer;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      /* Thinner crosshair */
      height: 10px;
      background-color: white;
      transform: translate(-50%, -50%);
      pointer-events: none;
      mix-blend-mode: difference;
    }

    #crosshair::before {
      /* Horizontal part of crosshair */
      content: '';
      position: absolute;
      top: 50%;
      left: -4px;
      /* (10px - 2px) / 2 */
      width: 10px;
      height: 2px;
      background-color: white;
      transform: translateY(-50%);
    }

    #block-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      gap: 10px;
    }

    .block-option {
      width: 40px;
      height: 40px;
      border: 2px solid #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      user-select: none;
      /* Prevent text selection */
    }

    .block-option.selected {
      border-color: white;
      box-shadow: 0 0 10px cyan;
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <h1>MiniCraft.js</h1>
      <p>Click to play</p>
      <p>WASD: Move<br>Space: Jump<br>Shift: Descend<br>Mouse: Look<br>Left Click: Place Block<br>Right Click: Remove
        Block<br>1-4: Select Block Type</p>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="block-selector"></div>

  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, camera, renderer, controls;
    let worldObjects = []; // To keep track of breakable/placeable blocks
    const worldSize = { width: 20, depth: 20, height: 10 };
    const blockSize = 1;

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let moveUp = false; // Jump
    let moveDown = false; // Descend (like creative mode fly)

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const playerSpeed = 5.0;
    const jumpVelocity = 8.0;
    const gravity = 20.0;
    let canJump = false;

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    const blockTypes = {
      GRASS: 'grass',
      DIRT: 'dirt',
      STONE: 'stone',
      WOOD: 'wood'
    };
    let currentBlockType = blockTypes.GRASS;
    const blockMaterials = {};

    // --- CRITICAL INITIALIZATION FOR ANIMATION LOOP ---
    let lastTime = performance.now();
    // --- END CRITICAL INITIALIZATION ---

    init();
    animate(); // Start the animation loop

    function createTexture(color, text = null) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.fillRect(0, 0, 64, 64);
      context.strokeStyle = 'rgba(0,0,0,0.2)';
      context.lineWidth = 2;
      context.strokeRect(1, 1, 62, 62); // Add a subtle border, inset slightly
      if (text) {
        context.fillStyle = 'rgba(0,0,0,0.5)';
        context.font = '12px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 32, 32);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace; // Important for colors with MeshStandardMaterial
      texture.magFilter = THREE.NearestFilter;   // Pixelated look
      texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    function initMaterials() {
      const grassTopTexture = createTexture('#6A994E');
      const grassSideTexture = createTexture('#A7C957');
      const dirtTexture = createTexture('#8C6A48');
      const stoneTexture = createTexture('#808080');
      const woodTexture = createTexture('#A0522D');

      blockMaterials[blockTypes.GRASS] = [
        grassSideTexture, grassSideTexture, // left, right
        grassTopTexture, dirtTexture,      // top, bottom
        grassSideTexture, grassSideTexture  // front, back
      ].map(texture => new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9, metalness: 0.1 }));

      blockMaterials[blockTypes.DIRT] = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.9, metalness: 0 });
      blockMaterials[blockTypes.STONE] = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.2 });
      blockMaterials[blockTypes.WOOD] = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 10, 75); // Start fog a bit further

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(worldSize.width / 4, worldSize.height + 2, worldSize.depth / 4);

      renderer = new THREE.WebGLRenderer({ antialias: true }); // Antialias can be true for smoother lines
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Slightly brighter ambient
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly stronger directional
      directionalLight.position.set(50, 80, 30);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048; // Higher res shadow map
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 200;
      const shadowCamSize = 30;
      directionalLight.shadow.camera.left = -shadowCamSize;
      directionalLight.shadow.camera.right = shadowCamSize;
      directionalLight.shadow.camera.top = shadowCamSize;
      directionalLight.shadow.camera.bottom = -shadowCamSize;
      scene.add(directionalLight);
      // const helper = new THREE.CameraHelper( directionalLight.shadow.camera );
      // scene.add( helper );


      initMaterials();
      generateWorld();

      controls = new PointerLockControls(camera, document.body);
      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');

      instructions.addEventListener('click', () => controls.lock());
      controls.addEventListener('lock', () => {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
      });
      controls.addEventListener('unlock', () => {
        blocker.style.display = 'flex';
        instructions.style.display = '';
      });
      scene.add(controls.getObject());

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('mousedown', onMouseDown);

      setupBlockSelector();
    }

    function generateWorld() {
      const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

      for (let x = 0; x < worldSize.width; x++) {
        for (let z = 0; z < worldSize.depth; z++) {
          const groundLevel = Math.floor(worldSize.height / 3);
          const height = groundLevel + Math.floor(Math.random() * 3);
          for (let y = 0; y < height; y++) {
            let material;
            let blockType;
            if (y === height - 1 && y >= groundLevel) {
              material = blockMaterials[blockTypes.GRASS];
              blockType = blockTypes.GRASS;
            } else if (y < height - 1 && y >= groundLevel - 2) {
              material = blockMaterials[blockTypes.DIRT];
              blockType = blockTypes.DIRT;
            }
            else {
              material = blockMaterials[blockTypes.STONE];
              blockType = blockTypes.STONE;
            }
            const block = new THREE.Mesh(boxGeometry, material);
            block.position.set(
              x * blockSize - (worldSize.width * blockSize / 2) + blockSize / 2,
              y * blockSize + blockSize / 2,
              z * blockSize - (worldSize.depth * blockSize / 2) + blockSize / 2
            );
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData.blockType = blockType;
            scene.add(block);
            worldObjects.push(block);
          }
        }
      }

      const groundGeo = new THREE.PlaneGeometry(worldSize.width * blockSize * 1.5, worldSize.depth * blockSize * 1.5);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x778899, side: THREE.DoubleSide, roughness: 1, metalness: 0 }); // LightSlateGray
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -blockSize / 2; // Ensure it's slightly below 0-level blocks
      ground.receiveShadow = true;
      scene.add(ground);
    }

    function setupBlockSelector() {
      const selectorDiv = document.getElementById('block-selector');
      Object.keys(blockTypes).forEach((key, index) => {
        const type = blockTypes[key];
        const option = document.createElement('div');
        option.classList.add('block-option');
        option.textContent = key.substring(0, 1);
        option.style.backgroundColor = getBlockColor(type);
        option.title = key; // Tooltip for block name
        option.dataset.blockType = type;
        if (type === currentBlockType) {
          option.classList.add('selected');
        }
        option.addEventListener('click', () => {
          currentBlockType = type;
          updateBlockSelectorUI();
        });
        selectorDiv.appendChild(option);
      });
    }

    function getBlockColor(type) {
      switch (type) {
        case blockTypes.GRASS: return '#6A994E';
        case blockTypes.DIRT: return '#8C6A48';
        case blockTypes.STONE: return '#808080';
        case blockTypes.WOOD: return '#A0522D';
        default: return '#FFFFFF';
      }
    }

    function updateBlockSelectorUI() {
      document.querySelectorAll('.block-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.blockType === currentBlockType);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      switch (event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'Space': if (canJump) velocity.y = jumpVelocity; canJump = false; break;
        case 'ShiftLeft': moveDown = true; break;
        case 'Digit1': currentBlockType = blockTypes.GRASS; updateBlockSelectorUI(); break;
        case 'Digit2': currentBlockType = blockTypes.DIRT; updateBlockSelectorUI(); break;
        case 'Digit3': currentBlockType = blockTypes.STONE; updateBlockSelectorUI(); break;
        case 'Digit4': currentBlockType = blockTypes.WOOD; updateBlockSelectorUI(); break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyD': moveRight = false; break;
        case 'ShiftLeft': moveDown = false; break;
      }
    }

    function onMouseDown(event) {
      if (!controls.isLocked) return;

      pointer.set(0, 0); // Raycast from center of camera
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(worldObjects, false); // Don't check descendants

      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (event.button === 2 || event.ctrlKey) { // Right click or Ctrl+LeftClick to remove
          if (intersect.object.userData.blockType) { // Ensure it's one of our blocks
            scene.remove(intersect.object);
            worldObjects.splice(worldObjects.indexOf(intersect.object), 1);
            if (intersect.object.geometry) intersect.object.geometry.dispose();
            if (intersect.object.material) {
              if (Array.isArray(intersect.object.material)) {
                intersect.object.material.forEach(m => m.dispose());
              } else {
                intersect.object.material.dispose();
              }
            }
          }
        } else if (event.button === 0) { // Left click to place
          const placementPosition = new THREE.Vector3();
          placementPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, blockSize);

          const playerHeadPos = controls.getObject().position.clone().add(new THREE.Vector3(0, 0.15, 0)); // Approx head
          const playerFeetPos = controls.getObject().position.clone().add(new THREE.Vector3(0, -1.65, 0)); // Approx feet

          const newBlockBox = new THREE.Box3().setFromCenterAndSize(
            placementPosition,
            new THREE.Vector3(blockSize, blockSize, blockSize)
          );
          // Check if player head or feet would be inside the new block
          if (newBlockBox.containsPoint(playerHeadPos) || newBlockBox.containsPoint(playerFeetPos)) {
            return; // Don't place block if player is intersecting
          }

          let blockExists = worldObjects.some(obj => obj.position.distanceTo(placementPosition) < 0.1);
          if (!blockExists) {
            const newBlockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const newBlockMaterial = blockMaterials[currentBlockType] || blockMaterials[blockTypes.STONE];
            const newBlock = new THREE.Mesh(newBlockGeometry, newBlockMaterial);
            newBlock.position.copy(placementPosition);
            newBlock.castShadow = true;
            newBlock.receiveShadow = true;
            newBlock.userData.blockType = currentBlockType;
            scene.add(newBlock);
            worldObjects.push(newBlock);
          }
        }
      }
    }

    const playerHeight = 1.8;
    const playerRadius = 0.4;

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - lastTime) / 1000;

      if (controls.isLocked) {
        const player = controls.getObject();
        const prevPosition = player.position.clone();

        // Apply gravity
        if (!canJump && !moveDown) { // Don't apply gravity if actively flying down
          velocity.y -= gravity * delta;
        }

        // Movement input
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveLeft) - Number(moveRight);
        direction.normalize(); // Ensure consistent speed diagonally

        if (moveForward || moveBackward) velocity.z = -direction.z * playerSpeed; else velocity.z = 0;
        if (moveLeft || moveRight) velocity.x = direction.x * playerSpeed; else velocity.x = 0;
        if (moveDown) velocity.y = -playerSpeed; // Creative fly down
        // Jump velocity is applied on keydown


        // Apply XZ movement based on camera direction
        player.translateX(velocity.x * delta);
        player.translateZ(velocity.z * delta);

        // Apply Y movement
        player.position.y += velocity.y * delta;

        // Collision detection
        let onGround = false;
        const playerFeetY = player.position.y - playerHeight / 2;
        const playerHeadY = player.position.y + playerHeight / 2;

        for (const block of worldObjects) {
          const blockBox = new THREE.Box3().setFromObject(block);

          // Broad phase check (simple distance)
          if (player.position.distanceTo(block.position) > blockSize * 2) continue;

          // Y-axis collision
          if (player.position.x > blockBox.min.x - playerRadius && player.position.x < blockBox.max.x + playerRadius &&
            player.position.z > blockBox.min.z - playerRadius && player.position.z < blockBox.max.z + playerRadius) {

            // Landing on block
            if (velocity.y <= 0 && playerFeetY < blockBox.max.y && prevPosition.y - playerHeight / 2 >= blockBox.max.y) {
              player.position.y = blockBox.max.y + playerHeight / 2;
              velocity.y = 0;
              onGround = true;
              canJump = true;
            }
            // Hitting head on block
            if (velocity.y > 0 && playerHeadY > blockBox.min.y && prevPosition.y + playerHeight / 2 <= blockBox.min.y) {
              player.position.y = blockBox.min.y - playerHeight / 2;
              velocity.y = 0;
            }
          }
        }

        // XZ-axis collision (simple push-out)
        for (const block of worldObjects) {
          const blockBox = new THREE.Box3().setFromObject(block);
          const playerBox = new THREE.Box3(
            new THREE.Vector3(player.position.x - playerRadius, player.position.y - playerHeight / 2, player.position.z - playerRadius),
            new THREE.Vector3(player.position.x + playerRadius, player.position.y + playerHeight / 2, player.position.z + playerRadius)
          );

          if (playerBox.intersectsBox(blockBox)) {
            const overlapX = Math.min(playerBox.max.x, blockBox.max.x) - Math.max(playerBox.min.x, blockBox.min.x);
            const overlapZ = Math.min(playerBox.max.z, blockBox.max.z) - Math.max(playerBox.min.z, blockBox.min.z);
            const overlapY = Math.min(playerBox.max.y, blockBox.max.y) - Math.max(playerBox.min.y, blockBox.min.y);

            // Check if collision is primarily on Y (already handled mostly)
            if (overlapY < overlapX && overlapY < overlapZ) {
              // This case should be less frequent if Y collision above works well
            } else if (overlapX < overlapZ) { // Resolve X
              if (player.position.x < block.position.x) player.position.x = blockBox.min.x - playerRadius;
              else player.position.x = blockBox.max.x + playerRadius;
              velocity.x = 0;
            } else { // Resolve Z
              if (player.position.z < block.position.z) player.position.z = blockBox.min.z - playerRadius;
              else player.position.z = blockBox.max.z + playerRadius;
              velocity.z = 0;
            }
          }
        }
        if (onGround) canJump = true;


        // Fall off world
        if (player.position.y < -30) {
          player.position.set(worldSize.width / 4, worldSize.height + 5, worldSize.depth / 4);
          velocity.set(0, 0, 0);
          canJump = false;
        }
      }

      renderer.render(scene, camera);
      lastTime = time;
    }

  </script>
</body>

</html>